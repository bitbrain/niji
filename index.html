<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="fediverse:creator" content="@bitbraindev@mastodon.gamedev.place">
  <title>niji · color space visualiser</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Baloo+2:wght@400;500;600&display=swap');

    :root {
      color-scheme: dark;
      font-family: "Baloo 2", "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background-color: #0a0503;
      color: #fff5ec;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at 15% 20%, rgba(255, 183, 131, 0.25), transparent 40%),
        radial-gradient(circle at 80% 0%, rgba(255, 137, 181, 0.18), transparent 45%),
        #0a0503;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      padding: 2.5rem 1.5rem 2rem;
    }

    header {
      width: 100%;
    }

    header h1 {
      margin: 0;
      font-size: clamp(2.3rem, 4vw, 3.3rem);
      letter-spacing: -0.02em;
      font-weight: 600;
      background: linear-gradient(90deg, #ff8ba7, #ffd166, #f4a259, #ff6b6b);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      filter: saturate(110%);
    }

    header p {
      margin: 0.35rem 0 0;
      color: #ffe3d2;
      font-size: 1rem;
    }

    footer {
      width: 100%;
      margin: auto;
      text-align: center;
      color: #ffb8de;
      font-size: 0.9rem;
    }

    footer a {
      color: #ffd2ff;
      text-decoration: none;
    }

    footer a:hover {
      color: #ffe4ff;
      text-decoration: underline;
    }

    main {
      width: 100%;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .app-layout {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .visual-panels {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1.5rem;
      align-items: start;
    }

    .visual-panels > * {
      min-width: 0;
    }

    .controls-row {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      align-items: stretch;
    }

    .panel-shell {
      background: none;
      border-radius: 0;
      padding: 0;
      box-shadow: none;
      border: none;
    }

    .controls-panel {
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    .controls-panel .controls-row .control-block {
      flex: 0 0 auto;
      min-width: 0;
    }

    .controls-panel select {
      width: 100%;
    }

    .control-block {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-size: 0.95rem;
      color: #ffe5c9;
      flex: 1 1 260px;
      min-width: 220px;
    }

    .control-title {
      font-weight: 600;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #ffecd9;
    }

    .color-space-block {
      position: relative;
    }

    .panel-header {
      margin-bottom: 0.1rem;
    }

    .panel-title {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #ffdac1;
      font-weight: 600;
    }

    .info-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-left: 0.4rem;
      width: 1.1rem;
      height: 1.1rem;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      font-size: 0.75rem;
      line-height: 1;
      cursor: default;
      color: #ffe5c9;
      background: transparent;
      padding: 0;
    }

    .info-icon:focus-visible {
      outline: 2px solid #ffd166;
      outline-offset: 2px;
    }

    .info-tooltip {
      position: absolute;
      top: 100%;
      left: 0;
      margin-top: 0.3rem;
      padding: 0.5rem 0.7rem;
      max-width: 260px;
      border-radius: 0.9rem;
      background: rgba(20, 9, 5, 0.97);
      color: #fff4e7;
      font-size: 0.78rem;
      line-height: 1.3;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.12);
      opacity: 0;
      transform: translateY(-4px);
      pointer-events: none;
      transition: opacity 0.12s ease, transform 0.12s ease;
      z-index: 10;
    }

    .info-tooltip.visible {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    .info-tooltip-title {
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 0.74rem;
      margin-bottom: 0.2rem;
      color: #ffe0c2;
    }

    .info-tooltip-axes {
      display: block;
      margin-top: 0.35rem;
      font-size: 0.74rem;
      color: #ffd2b1;
    }

    .adjustments-block {
      gap: 0.8rem;
    }

    .adjustments-group {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .sub-control {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-size: 0.85rem;
      color: #ffe5c9;
    }

    .sub-control-title {
      font-size: 0.85rem;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: #ffdccc;
    }

    .adjustments-actions {
      display: flex;
      justify-content: flex-end;
    }

    .preview-section {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    figure {
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    input[type="file"],
    select,
    input[type="range"] {
      border: none;
      border-radius: 1.1rem;
      background: rgba(255, 255, 255, 0.12);
      color: inherit;
      padding: 0.6rem 0.85rem;
      font: inherit;
      min-width: 180px;
      box-shadow: none;
    }

    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      padding: 0;
      background: transparent;
      border-radius: 999px;
      height: auto;
    }

    input[type="range"]::-webkit-slider-runnable-track {
      height: 8px;
      border-radius: 999px;
      background: linear-gradient(90deg, #ffcd70, #ffa36c, #ff7ba5, #ff9770);
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff1d0;
      border: none;
      margin-top: -5px;
      box-shadow: none;
    }

    input[type="range"]::-moz-range-track {
      height: 8px;
      border-radius: 999px;
      background: linear-gradient(90deg, #ffcd70, #ffa36c, #ff7ba5, #ff9770);
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff1d0;
      border: none;
      box-shadow: none;
    }

    .range-input {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .range-input output {
      font-variant-numeric: tabular-nums;
      font-weight: 600;
      color: #ffd5b5;
      min-width: 4rem;
      text-align: right;
    }

    .status-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      justify-content: space-between;
    }

    .status {
      font-size: 0.92rem;
      color: #ffcfad;
      flex: 1 1 auto;
    }

    .reset-button {
      appearance: none;
      border: none;
      border-radius: 1rem;
      padding: 0.55rem 1.4rem;
      background: linear-gradient(100deg, #ffaf7a, #ff6f91);
      color: #fff8f1;
      font: inherit;
      font-size: 0.9rem;
      cursor: pointer;
      transition: transform 0.15s ease;
    }

    .reset-button:hover {
      transform: translateY(-1px);
    }

    .ghost-button {
      appearance: none;
      border: 1px solid rgba(255, 255, 255, 0.28);
      border-radius: 0.85rem;
      padding: 0.45rem 1.2rem;
      background: transparent;
      color: #ffe8d9;
      font: inherit;
      font-size: 0.85rem;
      cursor: pointer;
      transition: border-color 0.15s ease, color 0.15s ease;
    }

    .ghost-button:hover {
      border-color: rgba(255, 255, 255, 0.5);
      color: #fff9f2;
    }

    .cube-row {
      margin: 0;
    }

    .cube-row figure {
      width: 100%;
    }

    figcaption {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #ffdac1;
    }

    canvas {
      width: 100%;
      aspect-ratio: 4 / 3;
      border-radius: 1.3rem;
      background: rgba(27, 12, 8, 0.95);
      box-shadow: none;
    }

    #imageCanvas {
      cursor: pointer;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(27, 12, 8, 0.25));
    }

    #spaceCanvas {
      cursor: grab;
      background: radial-gradient(circle at 35% 20%, rgba(255, 213, 153, 0.35), rgba(27, 12, 8, 0.97));
      aspect-ratio: 3 / 2;
      min-height: clamp(360px, 55vh, 560px);
    }

    #spaceCanvas.dragging {
      cursor: grabbing;
    }

    .hint {
      margin: 0.5rem 0 0;
      color: #ffcfb2;
      font-size: 0.95rem;
      text-align: center;
    }

    .hidden {
      display: none;
    }

    .tooltip {
      position: fixed;
      padding: 0.45rem 0.75rem;
      border-radius: 0.9rem;
      background: rgba(32, 15, 9, 0.96);
      color: #fff0e4;
      font-size: 0.85rem;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.12s ease, transform 0.12s ease;
      z-index: 20;
      box-shadow: none;
    }

    .tooltip.visible {
      opacity: 1;
      transform: translateY(-2px);
    }

    @media (min-width: 1100px) {
      .app-layout {
        display: grid;
        grid-template-columns: minmax(0, 1fr) minmax(260px, 340px);
        align-items: flex-start;
        gap: 1.5rem;
      }

      .visual-panels {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .controls-panel {
        position: sticky;
        top: 1.5rem;
        max-height: calc(100vh - 3rem);
        overflow-y: auto;
      }
    }

    @media (max-width: 768px) {
      body {
        padding: 1.75rem 1rem 2rem;
      }
    }

    @media (max-width: 520px) {
      .controls-row {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>niji</h1>
    <p>Upload photos and visualize their color space.</p>
  </header>

  <input type="file" accept="image/*" id="fileInput" hidden>

  <main>
    <div class="app-layout">
      <div class="visual-panels">
        <section class="preview-section panel-shell">
          <figure>
            <figcaption>Image preview</figcaption>
            <canvas id="imageCanvas" tabindex="0"></canvas>
          </figure>
          <div class="status-row">
            <button type="button" class="reset-button hidden" id="resetButton">Reset</button>
          </div>
        </section>

        <section class="cube-row panel-shell hidden" id="cubeSection">
          <figure>
            <figcaption>Color cube</figcaption>
            <canvas id="spaceCanvas"></canvas>
          </figure>
        </section>
      </div>

      <section class="controls-panel panel-shell hidden" id="optionsSection">
        <header class="panel-header">
          <span class="panel-title">Options</span>
        </header>
        <div class="controls-row">
          <label class="control-block color-space-block">
            Color space
            <button
              type="button"
              class="info-icon"
              id="spaceInfoTrigger"
              aria-label="Information about the selected color space"
            >?</button>
            <div class="info-tooltip" id="spaceInfoTooltip" role="status" aria-live="polite"></div>
            <select id="spaceSelect">
              <option value="rgb">RGB</option>
              <option value="lab">Lab</option>
              <option value="lch">LCh</option>
              <option value="linrgb">Linear RGB</option>
              <option value="hsl">HSL</option>
              <option value="hsv">HSV</option>
              <option value="ycbcr">YCbCr</option>
              <option value="xyz">XYZ</option>
              <option value="xyy">xyY</option>
              <option value="oklab">OKLab</option>
              <option value="oklch">OKLCH</option>
            </select>
          </label>
          <label class="control-block">
            Color samples
            <div class="range-input">
              <input type="range" id="sampleSlider" min="200" max="10000" step="100" value="2000">
              <output id="sampleCountLabel" for="sampleSlider">2,000</output>
            </div>
          </label>
          <label class="control-block">
            Similar color tolerance
            <div class="range-input">
              <input type="range" id="toleranceSlider" min="2" max="50" step="1" value="2">
              <output id="toleranceLabel" for="toleranceSlider">2 ΔE</output>
            </div>
          </label>
        </div>

        <div class="control-block adjustments-block" id="spaceAdjustmentsBlock">
          <span class="control-title" id="spaceAdjustmentsTitle">Color space axes</span>
          <div class="adjustments-group" id="spaceAdjustmentsContainer"></div>
          <div class="adjustments-actions">
            <button type="button" class="ghost-button" id="resetSpaceAdjustmentsButton">
              Reset color space sliders
            </button>
          </div>
        </div>

        <div class="control-block adjustments-block">
          <span class="control-title">Image adjustments</span>
          <div class="adjustments-group">
            <label class="sub-control">
              <span class="sub-control-title">Brightness</span>
              <div class="range-input">
                <input type="range" id="brightnessSlider" min="-100" max="100" step="1" value="0">
                <output id="brightnessLabel" for="brightnessSlider">0</output>
              </div>
            </label>
            <label class="sub-control">
              <span class="sub-control-title">Contrast</span>
              <div class="range-input">
                <input type="range" id="contrastSlider" min="-100" max="100" step="1" value="0">
                <output id="contrastLabel" for="contrastSlider">0</output>
              </div>
            </label>
            <label class="sub-control">
              <span class="sub-control-title">Saturation</span>
              <div class="range-input">
                <input type="range" id="saturationSlider" min="0" max="200" step="1" value="100">
                <output id="saturationLabel" for="saturationSlider">100%</output>
              </div>
            </label>
          </div>
          <div class="adjustments-actions">
            <button type="button" class="ghost-button" id="resetAdjustmentsButton">Reset adjustments</button>
          </div>
        </div>
      </section>
    </div>
  </main>

  <footer>
    made by <a rel="me" href="https://mastodon.gamedev.place/@bitbraindev">bitbrain</a> with ❤️
  </footer>

  <script>
    const fileInput = document.getElementById('fileInput');
    const spaceSelect = document.getElementById('spaceSelect');
    const sampleSlider = document.getElementById('sampleSlider');
    const sampleCountLabel = document.getElementById('sampleCountLabel');
    const toleranceSlider = document.getElementById('toleranceSlider');
    const toleranceLabel = document.getElementById('toleranceLabel');
    const brightnessSlider = document.getElementById('brightnessSlider');
    const brightnessLabel = document.getElementById('brightnessLabel');
    const contrastSlider = document.getElementById('contrastSlider');
    const contrastLabel = document.getElementById('contrastLabel');
    const saturationSlider = document.getElementById('saturationSlider');
    const saturationLabel = document.getElementById('saturationLabel');
    const resetAdjustmentsButton = document.getElementById('resetAdjustmentsButton');
    const spaceAdjustmentsBlock = document.getElementById('spaceAdjustmentsBlock');
    const spaceAdjustmentsTitle = document.getElementById('spaceAdjustmentsTitle');
    const spaceAdjustmentsContainer = document.getElementById('spaceAdjustmentsContainer');
    const resetSpaceAdjustmentsButton = document.getElementById('resetSpaceAdjustmentsButton');
    const imageCanvas = document.getElementById('imageCanvas');
    const resetButton = document.getElementById('resetButton');
    const spaceCanvas = document.getElementById('spaceCanvas');
    const cubeSection = document.getElementById('cubeSection');
    const optionsSection = document.getElementById('optionsSection');
    const spaceInfoTrigger = document.getElementById('spaceInfoTrigger');
    const spaceInfoTooltip = document.getElementById('spaceInfoTooltip');
    const imageCtx = imageCanvas.getContext('2d');
    const spaceCtx = spaceCanvas.getContext('2d');
    const sampleCanvas = document.createElement('canvas');
    const sampleCtx = sampleCanvas.getContext('2d');
    const tooltip = document.createElement('div');
    tooltip.className = 'tooltip';
    document.body.appendChild(tooltip);

    const cubeVertices = [
      { x: 0, y: 0, z: 0 },
      { x: 1, y: 0, z: 0 },
      { x: 0, y: 1, z: 0 },
      { x: 1, y: 1, z: 0 },
      { x: 0, y: 0, z: 1 },
      { x: 1, y: 0, z: 1 },
      { x: 0, y: 1, z: 1 },
      { x: 1, y: 1, z: 1 }
    ];

    const cubeEdges = [
      [0, 1], [0, 2], [1, 3], [2, 3],
      [4, 5], [4, 6], [5, 7], [6, 7],
      [0, 4], [1, 5], [2, 6], [3, 7]
    ];

    const axisLabels = {
      rgb: ['R', 'G', 'B'],
      lab: ['a*', 'b*', 'L*'],
      lch: ['C*', 'h°', 'L*'],
      linrgb: ['R (lin)', 'G (lin)', 'B (lin)'],
      hsl: ['H°', 'S', 'L'],
      hsv: ['H°', 'S', 'V'],
      ycbcr: ['Y', 'Cb', 'Cr'],
      xyz: ['X', 'Y', 'Z'],
      xyy: ['x', 'y', 'Y'],
      oklab: ['L', 'a', 'b'],
      oklch: ['L', 'C', 'h°']
    };

    const MAX_CHROMA = 150;
    const OK_MAX_CHROMA = 0.4;
    const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
    const REF_WHITE_X = 0.95047;
    const REF_WHITE_Y = 1.0;
    const REF_WHITE_Z = 1.08883;

    const spaceDescriptions = {
      rgb: {
        title: 'RGB (sRGB)',
        body: 'Standard display color space. Values describe red, green and blue channel intensities of your monitor.',
        axes: 'R / G / B: channel intensities from dark (0) to bright (255).'
      },
      lab: {
        title: 'CIELAB (Lab)',
        body: 'Perceptually uniform space designed so equal distances roughly match equal visual differences.',
        axes: 'a*: green (−) to red (+), b*: blue (−) to yellow (+), L*: lightness from dark to light.'
      },
      lch: {
        title: 'CIELCh (LCh)',
        body: 'Lab in cylindrical form: lightness, chroma and hue angle, closer to how we talk about color.',
        axes: 'L*: lightness, C*: chroma (colorfulness), h°: hue angle around the circle.'
      },
      linrgb: {
        title: 'Linear RGB',
        body: 'Same primaries as sRGB but without gamma, useful for showing how light actually adds up.',
        axes: 'R (lin) / G (lin) / B (lin): linear channel intensities proportional to light.'
      },
      hsl: {
        title: 'HSL',
        body: 'Hue–Saturation–Lightness, similar to many design tool sliders, but not perceptually uniform.',
        axes: 'H°: hue angle, S: saturation from gray to vivid, L: lightness from dark to light.'
      },
      hsv: {
        title: 'HSV',
        body: 'Hue–Saturation–Value, common in pickers where “value” tracks the brightest channel.',
        axes: 'H°: hue angle, S: saturation, V: value/brightness.'
      },
      ycbcr: {
        title: 'YCbCr',
        body: 'Luma–chroma space widely used in video and compression formats.',
        axes: 'Y: luma (brightness), Cb: blue–difference chroma, Cr: red–difference chroma.'
      },
      xyz: {
        title: 'CIEXYZ',
        body: 'Device‑independent foundation of colorimetry based on human cone responses.',
        axes: 'X / Y / Z: tristimulus values relative to a reference white.'
      },
      xyy: {
        title: 'xyY',
        body: 'Chromaticity plus luminance: separates color of the light from its intensity.',
        axes: 'x, y: chromaticity coordinates; Y: luminance/lightness.'
      },
      oklab: {
        title: 'OKLab',
        body: 'Modern perceptual space with smoother hue lines and more uniform lightness than Lab.',
        axes: 'L: lightness, a: green (−) to red (+), b: blue (−) to yellow (+).'
      },
      oklch: {
        title: 'OKLCH',
        body: 'Cylindrical OKLab that behaves well for modern color gradients and palettes.',
        axes: 'L: lightness, C: chroma (color strength), h°: hue angle.'
      }
    };

    const colorSpaceAdjustmentDefinitions = {
      rgb: {
        title: 'RGB axes',
        axes: [
          {
            id: 'r',
            label: 'Red',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => (value / 100) * 255
          },
          {
            id: 'g',
            label: 'Green',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => (value / 100) * 255
          },
          {
            id: 'b',
            label: 'Blue',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => (value / 100) * 255
          }
        ],
        apply(rgb, deltas = {}) {
          return [
            clamp(Math.round(rgb[0] + (deltas.r ?? 0)), 0, 255),
            clamp(Math.round(rgb[1] + (deltas.g ?? 0)), 0, 255),
            clamp(Math.round(rgb[2] + (deltas.b ?? 0)), 0, 255)
          ];
        }
      },
      lab: {
        title: 'Lab axes',
        axes: [
          {
            id: 'L',
            label: 'L*',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatSigned
          },
          {
            id: 'a',
            label: 'a*',
            min: -150,
            max: 150,
            step: 1,
            defaultValue: 0,
            formatter: formatSigned
          },
          {
            id: 'b',
            label: 'b*',
            min: -150,
            max: 150,
            step: 1,
            defaultValue: 0,
            formatter: formatSigned
          }
        ],
        apply(rgb, deltas = {}) {
          const lab = rgbToLab(rgb[0], rgb[1], rgb[2]);
          const nextL = clamp(lab.L + (deltas.L ?? 0), 0, 100);
          const nextA = clamp(lab.a + (deltas.a ?? 0), -150, 150);
          const nextB = clamp(lab.b + (deltas.b ?? 0), -150, 150);
          const nextRgb = labToRgb(nextL, nextA, nextB);
          return nextRgb ?? rgb;
        }
      },
      lch: {
        title: 'LCh axes',
        axes: [
          {
            id: 'L',
            label: 'Lightness',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatSigned
          },
          {
            id: 'C',
            label: 'Chroma',
            min: -150,
            max: 150,
            step: 1,
            defaultValue: 0,
            formatter: formatSigned
          },
          {
            id: 'h',
            label: 'Hue',
            min: -180,
            max: 180,
            step: 1,
            defaultValue: 0,
            formatter: formatDegreeLabel
          }
        ],
        apply(rgb, deltas = {}) {
          const lab = rgbToLab(rgb[0], rgb[1], rgb[2]);
          const lch = labToLch(lab.L, lab.a, lab.b);
          const nextL = clamp(lch.L + (deltas.L ?? 0), 0, 100);
          const nextC = clamp(lch.C + (deltas.C ?? 0), 0, MAX_CHROMA);
          const nextH = wrapDegrees((Number.isFinite(lch.h) ? lch.h : 0) + (deltas.h ?? 0));
          const nextLab = lchToLab(nextL, nextC, nextH);
          const nextRgb = labToRgb(nextLab.L, nextLab.a, nextLab.b);
          return nextRgb ?? rgb;
        }
      },
      linrgb: {
        title: 'Linear RGB axes',
        axes: [
          {
            id: 'r',
            label: 'Red (lin)',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => value / 100
          },
          {
            id: 'g',
            label: 'Green (lin)',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => value / 100
          },
          {
            id: 'b',
            label: 'Blue (lin)',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => value / 100
          }
        ],
        apply(rgb, deltas = {}) {
          const [rLin, gLin, bLin] = rgbToLinearRgb(
            rgb[0] / 255,
            rgb[1] / 255,
            rgb[2] / 255
          );
          const nextR = clamp(rLin + (deltas.r ?? 0), 0, 1);
          const nextG = clamp(gLin + (deltas.g ?? 0), 0, 1);
          const nextB = clamp(bLin + (deltas.b ?? 0), 0, 1);
          return linearRgbToSrgb(nextR, nextG, nextB);
        }
      },
      hsl: {
        title: 'HSL axes',
        axes: [
          {
            id: 'h',
            label: 'Hue',
            min: -180,
            max: 180,
            step: 1,
            defaultValue: 0,
            formatter: formatDegreeLabel
          },
          {
            id: 's',
            label: 'Saturation',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => value / 100
          },
          {
            id: 'l',
            label: 'Lightness',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => value / 100
          }
        ],
        apply(rgb, deltas = {}) {
          const hsl = rgbToHsl(rgb[0], rgb[1], rgb[2]);
          const hue = Number.isFinite(hsl.h) ? hsl.h : 0;
          const nextH = wrapDegrees(hue + (deltas.h ?? 0));
          const nextS = clamp(hsl.s + (deltas.s ?? 0), 0, 1);
          const nextL = clamp(hsl.l + (deltas.l ?? 0), 0, 1);
          return hslToRgb(nextH, nextS, nextL);
        }
      },
      hsv: {
        title: 'HSV axes',
        axes: [
          {
            id: 'h',
            label: 'Hue',
            min: -180,
            max: 180,
            step: 1,
            defaultValue: 0,
            formatter: formatDegreeLabel
          },
          {
            id: 's',
            label: 'Saturation',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => value / 100
          },
          {
            id: 'v',
            label: 'Value',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => value / 100
          }
        ],
        apply(rgb, deltas = {}) {
          const hsv = rgbToHsv(rgb[0], rgb[1], rgb[2]);
          const hue = Number.isFinite(hsv.h) ? hsv.h : 0;
          const nextH = wrapDegrees(hue + (deltas.h ?? 0));
          const nextS = clamp(hsv.s + (deltas.s ?? 0), 0, 1);
          const nextV = clamp(hsv.v + (deltas.v ?? 0), 0, 1);
          return hsvToRgb(nextH, nextS, nextV);
        }
      },
      ycbcr: {
        title: 'YCbCr axes',
        axes: [
          {
            id: 'y',
            label: 'Y (luma)',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => value / 100
          },
          {
            id: 'cb',
            label: 'Cb',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => value / 100
          },
          {
            id: 'cr',
            label: 'Cr',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => value / 100
          }
        ],
        apply(rgb, deltas = {}) {
          const { y, cb, cr } = rgbToYcbcr(rgb[0], rgb[1], rgb[2]);
          const nextY = clamp(y + (deltas.y ?? 0), 0, 1);
          const nextCb = clamp(cb + (deltas.cb ?? 0), 0, 1);
          const nextCr = clamp(cr + (deltas.cr ?? 0), 0, 1);
          return ycbcrToRgb(nextY, nextCb, nextCr);
        }
      },
      xyz: {
        title: 'XYZ axes',
        axes: [
          {
            id: 'x',
            label: 'X',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => (value / 100) * REF_WHITE_X
          },
          {
            id: 'y',
            label: 'Y',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => (value / 100) * REF_WHITE_Y
          },
          {
            id: 'z',
            label: 'Z',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => (value / 100) * REF_WHITE_Z
          }
        ],
        apply(rgb, deltas = {}) {
          const xyz = rgbToXyz(rgb[0], rgb[1], rgb[2]);
          const nextX = clamp(xyz[0] + (deltas.x ?? 0), 0, REF_WHITE_X);
          const nextY = clamp(xyz[1] + (deltas.y ?? 0), 0, REF_WHITE_Y);
          const nextZ = clamp(xyz[2] + (deltas.z ?? 0), 0, REF_WHITE_Z);
          const nextRgb = xyzToRgb(nextX, nextY, nextZ);
          return nextRgb ?? rgb;
        }
      },
      xyy: {
        title: 'xyY axes',
        axes: [
          {
            id: 'x',
            label: 'x',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => value / 100
          },
          {
            id: 'y',
            label: 'y',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => value / 100
          },
          {
            id: 'Y',
            label: 'Y (luminance)',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => value / 100
          }
        ],
        apply(rgb, deltas = {}) {
          const xyz = rgbToXyz(rgb[0], rgb[1], rgb[2]);
          const { x, y, Y } = xyzToXyy(xyz[0], xyz[1], xyz[2]);
          const nextX = clamp(x + (deltas.x ?? 0), 0, 1);
          const nextY = clamp(y + (deltas.y ?? 0), 0, 1);
          const nextLuma = clamp(Y + (deltas.Y ?? 0), 0, 1);
          const xyzNext = xyyToXyz(nextX, Math.max(nextY, 0.0001), nextLuma);
          const nextRgb = xyzToRgb(xyzNext.x, xyzNext.y, xyzNext.z);
          return nextRgb ?? rgb;
        }
      },
      oklab: {
        title: 'OKLab axes',
        axes: [
          {
            id: 'L',
            label: 'L',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => value / 100
          },
          {
            id: 'a',
            label: 'a',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => (value / 100) * OK_MAX_CHROMA
          },
          {
            id: 'b',
            label: 'b',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => (value / 100) * OK_MAX_CHROMA
          }
        ],
        apply(rgb, deltas = {}) {
          const oklab = rgbToOklab(rgb[0], rgb[1], rgb[2]);
          const nextL = clamp(oklab.L + (deltas.L ?? 0), 0, 1);
          const nextA = clamp(oklab.a + (deltas.a ?? 0), -OK_MAX_CHROMA, OK_MAX_CHROMA);
          const nextB = clamp(oklab.b + (deltas.b ?? 0), -OK_MAX_CHROMA, OK_MAX_CHROMA);
          return oklabToRgb(nextL, nextA, nextB);
        }
      },
      oklch: {
        title: 'OKLCH axes',
        axes: [
          {
            id: 'L',
            label: 'Lightness',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => value / 100
          },
          {
            id: 'C',
            label: 'Chroma',
            min: -100,
            max: 100,
            step: 1,
            defaultValue: 0,
            formatter: formatPercentLabel,
            toDelta: (value) => (value / 100) * OK_MAX_CHROMA
          },
          {
            id: 'h',
            label: 'Hue',
            min: -180,
            max: 180,
            step: 1,
            defaultValue: 0,
            formatter: formatDegreeLabel
          }
        ],
        apply(rgb, deltas = {}) {
          const oklab = rgbToOklab(rgb[0], rgb[1], rgb[2]);
          const oklch = oklabToOklch(oklab.L, oklab.a, oklab.b);
          const nextL = clamp(oklch.L + (deltas.L ?? 0), 0, 1);
          const nextC = clamp(oklch.C + (deltas.C ?? 0), 0, OK_MAX_CHROMA);
          const nextH = wrapDegrees((Number.isFinite(oklch.h) ? oklch.h : 0) + (deltas.h ?? 0));
          const nextLab = oklchToOklab(nextL, nextC, nextH);
          return oklabToRgb(nextLab.L, nextLab.a, nextLab.b);
        }
      }
    };
    const HOVER_PICK_RADIUS = 9;
    const BASE_POINT_RADIUS = 3;
    const HOVER_RADIUS_DELTA = 4;
    const ROTATION_EASING = 0.18;
    const ZOOM_EASING = 0.16;
    const HOVER_EASING = 0.25;
    const DEFAULT_HIGHLIGHT_DELTA = 2;
    const DIM_FACTOR = 0.14;
    const DEFAULT_ADJUSTMENTS = Object.freeze({
      brightness: 0,
      contrast: 0,
      saturation: 100
    });

    const referenceGrid = createReferenceGrid(6);
    const spaceAdjustmentState = {};
    const spaceAxisElements = new Map();

    let loadedImage = null;
    let samples = [];
    let rotation = { x: -0.9, y: 0.9 };
    let targetRotation = { x: rotation.x, y: rotation.y };
    let zoom = 1;
    let targetZoom = 1;
    let isDragging = false;
    let lastPointer = { x: 0, y: 0 };
    let pinchDistance = null;
    let pinchZoomStart = null;
    let projectedSamples = [];
    let hoveredSample = null;
    let hoveredHex = '';
    let tooltipCopyTimeout = null;
    let tooltipPosition = { x: 0, y: 0 };
    let dragMoved = false;
    let sampleTarget = parseInt(sampleSlider?.value ?? '2000', 10) || 2000;
    let highlightTolerance = parseInt(
      toleranceSlider?.value ?? String(DEFAULT_HIGHLIGHT_DELTA),
      10
    ) || DEFAULT_HIGHLIGHT_DELTA;
    let imageAdjustments = { ...DEFAULT_ADJUSTMENTS };
    let hoverAmount = 0;
    let hoverAmountTarget = 0;
    let hoverSource = null;
    let needsRender = true;
    let lastFrameTime = 0;
    let imageImageData = null;
    let imageLabBuffer = null;
    let highlightImageData = null;
    let highlightActive = false;
    let lastHighlightSample = null;
    let imageDrawRegion = { x: 0, y: 0, width: 0, height: 0 };

    fileInput.addEventListener('change', handleImageUpload);
    spaceSelect.addEventListener('change', () => {
      clearHover(false);
      requestRender();
      updateSpaceInfo();
      renderSpaceAdjustmentControls();
      handleSpaceAdjustmentChange();
    });
    sampleSlider.addEventListener('input', handleSampleChange);
    toleranceSlider?.addEventListener('input', handleToleranceChange);
    brightnessSlider?.addEventListener('input', () => handleAdjustmentChange('brightness'));
    contrastSlider?.addEventListener('input', () => handleAdjustmentChange('contrast'));
    saturationSlider?.addEventListener('input', () => handleAdjustmentChange('saturation'));
    resetAdjustmentsButton?.addEventListener('click', resetAdjustments);
    resetSpaceAdjustmentsButton?.addEventListener('click', resetSpaceAdjustmentsForCurrentMode);
    imageCanvas.addEventListener('click', handleImageClick);
    imageCanvas.addEventListener('keydown', handlePreviewKey);
    imageCanvas.addEventListener('mousemove', handleImageHover);
    imageCanvas.addEventListener('mouseleave', handleImageLeave);
    resetButton.addEventListener('click', resetImage);

    window.addEventListener('resize', () => {
      const changedImage = resizeCanvas(imageCanvas);
      const changedSpace = resizeCanvas(spaceCanvas);
      if (changedImage) redrawImage();
      if (changedSpace) requestRender();
    });

    spaceCanvas.addEventListener('mousedown', (event) => {
      startDrag(event);
      clearHover(false);
    });
    window.addEventListener('mouseup', endDrag);
    spaceCanvas.addEventListener('mouseleave', () => {
      endDrag();
      clearHover();
    });
    spaceCanvas.addEventListener('mousemove', (event) => {
      dragMove(event);
      handleHover(event);
    });
    spaceCanvas.addEventListener('click', handleCanvasClick);
    spaceCanvas.addEventListener('wheel', adjustZoom, { passive: false });
    spaceCanvas.addEventListener('touchstart', handleTouchStart, { passive: false });
    spaceCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    spaceCanvas.addEventListener('touchend', handleTouchEnd);
    spaceCanvas.addEventListener('touchcancel', handleTouchEnd);

    syncSampleLabel();
    syncToleranceLabel();
    syncAdjustmentLabels();
    renderSpaceAdjustmentControls();
    setColorUiVisible(false);
    updateSpaceInfo();
    initializeCanvases();
    drawPlaceholderImage();
    requestAnimationFrame(animationLoop);

    if (spaceInfoTrigger && spaceInfoTooltip) {
      spaceInfoTrigger.addEventListener('mouseenter', () => {
        spaceInfoTooltip.classList.add('visible');
      });
      spaceInfoTrigger.addEventListener('mouseleave', () => {
        spaceInfoTooltip.classList.remove('visible');
      });
      spaceInfoTrigger.addEventListener('focus', () => {
        spaceInfoTooltip.classList.add('visible');
      });
      spaceInfoTrigger.addEventListener('blur', () => {
        spaceInfoTooltip.classList.remove('visible');
      });
    }

    function initializeCanvases() {
      resizeCanvas(imageCanvas);
      resizeCanvas(spaceCanvas);
    }

    function updateSpaceInfo() {
      if (!spaceInfoTooltip || !spaceSelect) return;
      const mode = spaceSelect.value;
      const info = spaceDescriptions[mode];
      if (!info) {
        spaceInfoTooltip.textContent = '';
        return;
      }
      spaceInfoTooltip.innerHTML = `
        <div class="info-tooltip-title">${info.title}</div>
        <div>${info.body}</div>
        <span class="info-tooltip-axes">${info.axes}</span>
      `;
    }

    function resizeCanvas(canvas) {
      const { width, height } = canvas.getBoundingClientRect();
      if (!width || !height) return false;
      const roundedWidth = Math.round(width);
      const roundedHeight = Math.round(height);
      if (canvas.width !== roundedWidth || canvas.height !== roundedHeight) {
        canvas.width = roundedWidth;
        canvas.height = roundedHeight;
        return true;
      }
      return false;
    }

    function handleImageUpload(event) {
      const file = event.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          loadedImage = img;
          redrawImage();
          resampleImage();
          setColorUiVisible(true);
        };
        img.src = reader.result;
      };
      reader.readAsDataURL(file);
      event.target.value = '';
    }

    function redrawImage() {
      imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
      if (!loadedImage) {
        drawPlaceholderImage();
        return;
      }
      const { width, height } = fitCover(
        loadedImage.width,
        loadedImage.height,
        imageCanvas.width,
        imageCanvas.height
      );
      const offsetX = (imageCanvas.width - width) / 2;
      const offsetY = (imageCanvas.height - height) / 2;
      imageCtx.drawImage(loadedImage, offsetX, offsetY, width, height);
      imageDrawRegion = { x: offsetX, y: offsetY, width, height };
      applyAdjustmentsToRegion(offsetX, offsetY, width, height);
      cacheImageData();
      if (hoveredSample) {
        applyImageHighlight(hoveredSample);
      }
    }

    function applyAdjustmentsToRegion(x, y, width, height) {
      if (!loadedImage || width <= 0 || height <= 0) return;
      const adjustmentContext = getAdjustmentContext();
      if (adjustmentContext.isIdentity) return;
      const regionX = Math.max(0, Math.floor(x));
      const regionY = Math.max(0, Math.floor(y));
      const regionWidth = Math.min(imageCanvas.width - regionX, Math.ceil(width));
      const regionHeight = Math.min(imageCanvas.height - regionY, Math.ceil(height));
      if (regionWidth <= 0 || regionHeight <= 0) return;
      const imageData = imageCtx.getImageData(regionX, regionY, regionWidth, regionHeight);
      applyAdjustmentsToImageData(imageData, adjustmentContext);
      imageCtx.putImageData(imageData, regionX, regionY);
    }

    function applyAdjustmentsToImageData(imageData, adjustmentContext = getAdjustmentContext()) {
      if (adjustmentContext.isIdentity) return imageData;
      const { data } = imageData;
      for (let i = 0; i < data.length; i += 4) {
        const [r, g, b] = applyAdjustmentsToChannels(
          data[i],
          data[i + 1],
          data[i + 2],
          adjustmentContext
        );
        data[i] = r;
        data[i + 1] = g;
        data[i + 2] = b;
      }
      return imageData;
    }

    function applyAdjustmentsToChannels(r, g, b, adjustmentContext = getAdjustmentContext()) {
      if (adjustmentContext.isIdentity) {
        return [r, g, b];
      }
      const {
        brightnessOffset,
        contrastFactor,
        saturationFactor,
        spaceAdjustmentDescriptor,
        spaceAxisDeltas,
        hasSpaceAdjustments
      } = adjustmentContext;
      let nr = (r - 128) * contrastFactor + 128 + brightnessOffset;
      let ng = (g - 128) * contrastFactor + 128 + brightnessOffset;
      let nb = (b - 128) * contrastFactor + 128 + brightnessOffset;
      const gray = 0.299 * nr + 0.587 * ng + 0.114 * nb;
      nr = gray + (nr - gray) * saturationFactor;
      ng = gray + (ng - gray) * saturationFactor;
      nb = gray + (nb - gray) * saturationFactor;
      let adjusted = [
        clamp(Math.round(nr), 0, 255),
        clamp(Math.round(ng), 0, 255),
        clamp(Math.round(nb), 0, 255)
      ];
      if (hasSpaceAdjustments && spaceAdjustmentDescriptor && spaceAxisDeltas) {
        adjusted = applyColorSpaceDynamicAdjustment(adjusted, spaceAdjustmentDescriptor, spaceAxisDeltas);
      }
      return adjusted;
    }

    function applyColorSpaceDynamicAdjustment(rgb, descriptor, deltas) {
      if (!descriptor || typeof descriptor.apply !== 'function' || !deltas) {
        return rgb;
      }
      const next = descriptor.apply(rgb, deltas);
      if (!Array.isArray(next) || next.length !== 3) {
        return rgb;
      }
      return [
        clamp(Math.round(next[0]), 0, 255),
        clamp(Math.round(next[1]), 0, 255),
        clamp(Math.round(next[2]), 0, 255)
      ];
    }

    function getAdjustmentContext() {
      const brightness = clamp(imageAdjustments.brightness ?? 0, -100, 100);
      const contrast = clamp(imageAdjustments.contrast ?? 0, -100, 100);
      const saturation = clamp(imageAdjustments.saturation ?? 100, 0, 200);
      const mode = spaceSelect?.value ?? 'rgb';
      const descriptor = colorSpaceAdjustmentDefinitions[mode];
      const { deltas, hasAdjustments } = descriptor
        ? getSpaceAdjustmentDeltas(mode)
        : { deltas: null, hasAdjustments: false };
      const brightnessOffset = (brightness / 100) * 255;
      const contrastFactor = (contrast + 100) / 100;
      const saturationFactor = saturation / 100;
      const isIdentity = brightness === 0 && contrast === 0 && saturation === 100 && !hasAdjustments;
      return {
        brightnessOffset,
        contrastFactor,
        saturationFactor,
        isIdentity,
        spaceAdjustmentDescriptor: descriptor,
        spaceAxisDeltas: deltas,
        hasSpaceAdjustments: hasAdjustments
      };
    }

    function drawPlaceholderImage() {
      imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
      imageCtx.fillStyle = '#1c0e08';
      imageCtx.fillRect(0, 0, imageCanvas.width, imageCanvas.height);
      imageImageData = null;
      imageLabBuffer = null;
      highlightImageData = null;
      highlightActive = false;
      lastHighlightSample = null;
      imageDrawRegion = { x: 0, y: 0, width: imageCanvas.width, height: imageCanvas.height };
      const step = 28;
      imageCtx.strokeStyle = 'rgba(255, 179, 153, 0.2)';
      imageCtx.lineWidth = 1;
      for (let x = step; x < imageCanvas.width; x += step) {
        imageCtx.beginPath();
        imageCtx.moveTo(x, 0);
        imageCtx.lineTo(x, imageCanvas.height);
        imageCtx.stroke();
      }
      for (let y = step; y < imageCanvas.height; y += step) {
        imageCtx.beginPath();
        imageCtx.moveTo(0, y);
        imageCtx.lineTo(imageCanvas.width, y);
        imageCtx.stroke();
      }
      imageCtx.fillStyle = '#ffbfa3';
      imageCtx.textAlign = 'center';
      imageCtx.textBaseline = 'middle';
      imageCtx.font = '500 14px "Inter", system-ui, sans-serif';
      imageCtx.fillText('Drop a photo here or pick one above', imageCanvas.width / 2, imageCanvas.height / 2);
    }

    function fitCover(srcWidth, srcHeight, maxWidth, maxHeight) {
      const scale = Math.max(maxWidth / srcWidth, maxHeight / srcHeight);
      return {
        width: srcWidth * scale,
        height: srcHeight * scale
      };
    }

    function cacheImageData() {
      if (!loadedImage) {
        imageImageData = null;
        imageLabBuffer = null;
        highlightImageData = null;
        highlightActive = false;
        lastHighlightSample = null;
        return;
      }
      if (!imageCanvas.width || !imageCanvas.height) return;
      imageImageData = imageCtx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
      const pixelCount = imageCanvas.width * imageCanvas.height;
      imageLabBuffer = new Float32Array(pixelCount * 3);
      const data = imageImageData.data;
      for (let i = 0, j = 0; i < data.length; i += 4, j += 3) {
        const lab = rgbToLab(data[i], data[i + 1], data[i + 2]);
        imageLabBuffer[j] = lab.L;
        imageLabBuffer[j + 1] = lab.a;
        imageLabBuffer[j + 2] = lab.b;
      }
      highlightImageData = imageCtx.createImageData(imageCanvas.width, imageCanvas.height);
      highlightActive = false;
      lastHighlightSample = null;
    }

    function resetImage() {
      loadedImage = null;
      samples = [];
      hoverSource = null;
      clearHover(false);
      drawPlaceholderImage();
      setColorUiVisible(false);
      requestRender();
      if (fileInput) fileInput.value = '';
    }

    function sampleImage(image) {
      const maxDimension = 640;
      const largestSide = Math.max(image.width, image.height);
      const scale = Math.min(1, maxDimension / largestSide);
      const w = Math.max(1, Math.round(image.width * scale));
      const h = Math.max(1, Math.round(image.height * scale));

      sampleCanvas.width = w;
      sampleCanvas.height = h;
      sampleCtx.drawImage(image, 0, 0, w, h);

      const sampledImageData = sampleCtx.getImageData(0, 0, w, h);
      const data = sampledImageData.data;
      const adjustmentContext = getAdjustmentContext();
      const targetSamples = Math.max(50, sampleTarget);
      const stride = Math.max(1, Math.round(Math.sqrt((w * h) / targetSamples)));
      const collected = [];

      for (let y = 0; y < h; y += stride) {
        for (let x = 0; x < w; x += stride) {
          const idx = (y * w + x) * 4;
          const r = data[idx];
          const g = data[idx + 1];
          const b = data[idx + 2];
          const [adjR, adjG, adjB] = applyAdjustmentsToChannels(r, g, b, adjustmentContext);
          const lab = rgbToLab(adjR, adjG, adjB);
          const lch = labToLch(lab.L, lab.a, lab.b);
          collected.push({ rgb: [adjR, adjG, adjB], lab, lch });
        }
      }

      return collected;
    }

    function drawSpace() {
      spaceCtx.clearRect(0, 0, spaceCanvas.width, spaceCanvas.height);
      spaceCtx.fillStyle = '#050912';
      spaceCtx.fillRect(0, 0, spaceCanvas.width, spaceCanvas.height);

      drawBackgroundPoints();
      drawCube();
      drawAxes();
      drawPoints();
    }

    function drawCube() {
      spaceCtx.save();
      spaceCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      spaceCtx.lineWidth = 1;
      cubeEdges.forEach(([start, end]) => {
        const a = project(cubeVertices[start]);
        const b = project(cubeVertices[end]);
        spaceCtx.beginPath();
        spaceCtx.moveTo(a.x, a.y);
        spaceCtx.lineTo(b.x, b.y);
        spaceCtx.stroke();
      });
      spaceCtx.restore();
    }

    function drawAxes() {
      const origin = project({ x: 0, y: 0, z: 0 });
      const axes = {
        x: project({ x: 1, y: 0, z: 0 }),
        y: project({ x: 0, y: 1, z: 0 }),
        z: project({ x: 0, y: 0, z: 1 })
      };

      spaceCtx.save();
      spaceCtx.strokeStyle = 'rgba(59, 130, 246, 0.55)';
      spaceCtx.lineWidth = 1.4;
      Object.values(axes).forEach((axis) => {
        spaceCtx.beginPath();
        spaceCtx.moveTo(origin.x, origin.y);
        spaceCtx.lineTo(axis.x, axis.y);
        spaceCtx.stroke();
      });

      const labels = axisLabels[spaceSelect.value];
      spaceCtx.fillStyle = 'rgba(248, 250, 252, 0.92)';
      spaceCtx.font = '700 20px "Inter", system-ui, sans-serif';
      spaceCtx.textAlign = 'center';
      spaceCtx.textBaseline = 'middle';
      spaceCtx.fillText(labels[0], axes.x.x + 32, axes.x.y + 4);
      spaceCtx.fillText(labels[1], axes.y.x - 4, axes.y.y - 28);
      spaceCtx.fillText(labels[2], axes.z.x - 20, axes.z.y - 22);
      spaceCtx.restore();
    }

    function drawBackgroundPoints() {
      const mode = spaceSelect.value;
      const background = [];
      referenceGrid.forEach((coords) => {
        const rgb = coordsToColor(mode, coords);
        if (!rgb) return;
        const point = project(coords);
        background.push({
          x: point.x,
          y: point.y,
          depth: point.depth,
          rgb
        });
      });
      background.sort((a, b) => a.depth - b.depth);

      spaceCtx.save();
      spaceCtx.globalAlpha = 0.18;
      background.forEach(({ x, y, rgb }) => {
        spaceCtx.beginPath();
        spaceCtx.fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
        spaceCtx.arc(x, y, 2, 0, Math.PI * 2);
        spaceCtx.fill();
      });
      spaceCtx.restore();
    }

    function drawPoints() {
      projectedSamples = [];
      if (!samples.length) return;
      const mode = spaceSelect.value;

      const projected = [];
      for (const sample of samples) {
        const coords = mapSample(sample, mode);
        if (!coords) continue;
        const point = project(coords);
        const entry = {
          x: point.x,
          y: point.y,
          depth: point.depth,
          rgb: sample.rgb,
          sample,
          hex: rgbToHex(sample.rgb),
          isHovered: hoveredSample === sample
        };
        projected.push(entry);
      }

      projectedSamples = projected;
      const sorted = projected.slice().sort((a, b) => a.depth - b.depth);

      spaceCtx.save();
      sorted.forEach(({ x, y, rgb, isHovered }) => {
        const radius = BASE_POINT_RADIUS + (isHovered ? hoverAmount * HOVER_RADIUS_DELTA : 0);
        spaceCtx.beginPath();
        spaceCtx.fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
        spaceCtx.globalAlpha = isHovered ? 1 : 0.92;
        spaceCtx.arc(x, y, radius, 0, Math.PI * 2);
        spaceCtx.fill();
        if (isHovered && hoverAmount > 0.05) {
          spaceCtx.globalAlpha = 0.85;
          spaceCtx.lineWidth = 1.5;
          spaceCtx.strokeStyle = 'rgba(248, 250, 252, 0.8)';
          spaceCtx.beginPath();
          spaceCtx.arc(x, y, radius + 1.5, 0, Math.PI * 2);
          spaceCtx.stroke();
        }
      });
      spaceCtx.restore();
    }

    function mapSample(sample, mode) {
      if (mode === 'rgb') {
        return {
          x: clamp(sample.rgb[0] / 255, 0, 1),
          y: clamp(sample.rgb[1] / 255, 0, 1),
          z: clamp(sample.rgb[2] / 255, 0, 1)
        };
      }
      if (mode === 'lab') {
        return {
          x: clamp((sample.lab.a + 128) / 255, 0, 1),
          y: clamp((sample.lab.b + 128) / 255, 0, 1),
          z: clamp(sample.lab.L / 100, 0, 1)
        };
      }
      if (mode === 'lch') {
        const hue = Number.isFinite(sample.lch.h) ? sample.lch.h : 0;
        return {
          x: clamp(sample.lch.C / MAX_CHROMA, 0, 1),
          y: clamp(hue / 360, 0, 1),
          z: clamp(sample.lch.L / 100, 0, 1)
        };
      }
      if (mode === 'linrgb') {
        const [rLin, gLin, bLin] = rgbToLinearRgb(
          sample.rgb[0] / 255,
          sample.rgb[1] / 255,
          sample.rgb[2] / 255
        );
        return {
          x: clamp(rLin, 0, 1),
          y: clamp(gLin, 0, 1),
          z: clamp(bLin, 0, 1)
        };
      }
      if (mode === 'hsl') {
        const { h, s, l } = rgbToHsl(
          sample.rgb[0],
          sample.rgb[1],
          sample.rgb[2]
        );
        const hue = Number.isFinite(h) ? h : 0;
        return {
          x: clamp(hue / 360, 0, 1),
          y: clamp(s, 0, 1),
          z: clamp(l, 0, 1)
        };
      }
      if (mode === 'hsv') {
        const { h, s, v } = rgbToHsv(
          sample.rgb[0],
          sample.rgb[1],
          sample.rgb[2]
        );
        const hue = Number.isFinite(h) ? h : 0;
        return {
          x: clamp(hue / 360, 0, 1),
          y: clamp(s, 0, 1),
          z: clamp(v, 0, 1)
        };
      }
      if (mode === 'ycbcr') {
        const { y, cb, cr } = rgbToYcbcr(
          sample.rgb[0],
          sample.rgb[1],
          sample.rgb[2]
        );
        return {
          x: clamp(y, 0, 1),
          y: clamp(cb, 0, 1),
          z: clamp(cr, 0, 1)
        };
      }
      if (mode === 'xyz' || mode === 'xyy') {
        const [x, y, z] = rgbToXyz(
          sample.rgb[0],
          sample.rgb[1],
          sample.rgb[2]
        );
        if (mode === 'xyz') {
          return {
            x: clamp(x / 0.95047, 0, 1),
            y: clamp(y / 1.0, 0, 1),
            z: clamp(z / 1.08883, 0, 1)
          };
        }
        const sum = x + y + z;
        const xx = sum > 0 ? x / sum : 0;
        const yy = sum > 0 ? y / sum : 0;
        return {
          x: clamp(xx, 0, 1),
          y: clamp(yy, 0, 1),
          z: clamp(y / 1.0, 0, 1)
        };
      }
      if (mode === 'oklab' || mode === 'oklch') {
        const oklab = rgbToOklab(
          sample.rgb[0],
          sample.rgb[1],
          sample.rgb[2]
        );
        if (mode === 'oklab') {
          return {
            x: clamp(0.5 + oklab.a / (2 * OK_MAX_CHROMA), 0, 1),
            y: clamp(0.5 + oklab.b / (2 * OK_MAX_CHROMA), 0, 1),
            z: clamp(oklab.L, 0, 1)
          };
        }
        const C = Math.sqrt(oklab.a * oklab.a + oklab.b * oklab.b);
        const h = (Math.atan2(oklab.b, oklab.a) * 180) / Math.PI;
        const hue = Number.isFinite(h) ? (h < 0 ? h + 360 : h) : 0;
        return {
          x: clamp(C / OK_MAX_CHROMA, 0, 1),
          y: clamp(hue / 360, 0, 1),
          z: clamp(oklab.L, 0, 1)
        };
      }
      return null;
    }

    function project(point) {
      const centered = {
        x: point.x - 0.5,
        y: point.y - 0.5,
        z: point.z - 0.5
      };

      const cosY = Math.cos(rotation.y);
      const sinY = Math.sin(rotation.y);
      let x = centered.x * cosY - centered.z * sinY;
      let z = centered.x * sinY + centered.z * cosY;

      const cosX = Math.cos(rotation.x);
      const sinX = Math.sin(rotation.x);
      let y = centered.y * cosX - z * sinX;
      z = centered.y * sinX + z * cosX;

      const scale = Math.min(spaceCanvas.width, spaceCanvas.height) * 0.55 * zoom;

      return {
        x: x * scale + spaceCanvas.width / 2,
        y: y * scale + spaceCanvas.height / 2,
        depth: z
      };
    }

    function startDrag(event) {
      isDragging = true;
      lastPointer = { x: event.clientX, y: event.clientY };
      spaceCanvas.classList.add('dragging');
      dragMoved = false;
    }

    function dragMove(event) {
      if (!isDragging) return;
      const dx = event.clientX - lastPointer.x;
      const dy = event.clientY - lastPointer.y;
      targetRotation.y += dx * 0.005;
      targetRotation.x += dy * 0.005;
      targetRotation.x = clamp(targetRotation.x, -Math.PI / 2, Math.PI / 2);
      lastPointer = { x: event.clientX, y: event.clientY };
      if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {
        dragMoved = true;
      }
      requestRender();
    }

    function endDrag() {
      isDragging = false;
      spaceCanvas.classList.remove('dragging');
      dragMoved = false;
    }

    function adjustZoom(event) {
      event.preventDefault();
      const delta = -event.deltaY * 0.001;
      targetZoom = clamp(targetZoom * (1 + delta), 0.4, 3);
      requestRender();
    }

    function handleTouchStart(event) {
      clearHover(false);
      if (event.touches.length === 1) {
        isDragging = true;
        lastPointer = { x: event.touches[0].clientX, y: event.touches[0].clientY };
        spaceCanvas.classList.add('dragging');
      } else if (event.touches.length === 2) {
        pinchDistance = getDistance(event.touches[0], event.touches[1]);
        pinchZoomStart = targetZoom;
      }
    }

    function handleTouchMove(event) {
      event.preventDefault();
      if (event.touches.length === 1 && isDragging) {
        const touch = event.touches[0];
        const dx = touch.clientX - lastPointer.x;
        const dy = touch.clientY - lastPointer.y;
        targetRotation.y += dx * 0.005;
        targetRotation.x += dy * 0.005;
        targetRotation.x = clamp(targetRotation.x, -Math.PI / 2, Math.PI / 2);
        lastPointer = { x: touch.clientX, y: touch.clientY };
        requestRender();
      } else if (event.touches.length === 2 && pinchDistance) {
        const newDistance = getDistance(event.touches[0], event.touches[1]);
        const ratio = newDistance / pinchDistance;
        targetZoom = clamp(pinchZoomStart * ratio, 0.4, 3);
        requestRender();
      }
    }

    function handleTouchEnd(event) {
      if (event.touches.length === 0) {
        isDragging = false;
        spaceCanvas.classList.remove('dragging');
        pinchDistance = null;
        pinchZoomStart = null;
        hideTooltip();
      } else if (event.touches.length === 1) {
        lastPointer = { x: event.touches[0].clientX, y: event.touches[0].clientY };
        pinchDistance = null;
        pinchZoomStart = null;
      }
    }

    function getDistance(a, b) {
      const dx = a.clientX - b.clientX;
      const dy = a.clientY - b.clientY;
      return Math.hypot(dx, dy);
    }

    function handleHover(event) {
      if (isDragging || !projectedSamples.length) {
        clearHover(true, 'cube');
        return;
      }
      const rect = spaceCanvas.getBoundingClientRect();
      const pointer = {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
      };

      let nearest = null;
      let minDist = Infinity;
      for (const point of projectedSamples) {
        const dx = point.x - pointer.x;
        const dy = point.y - pointer.y;
        const dist = Math.hypot(dx, dy);
        if (dist <= HOVER_PICK_RADIUS && dist < minDist) {
          minDist = dist;
          nearest = point;
        }
      }

      if (!nearest) {
        clearHover(true, 'cube');
        return;
      }

      if (hoveredSample !== nearest.sample || hoverSource !== 'cube') {
        hoveredSample = nearest.sample;
        hoveredHex = nearest.hex;
        hoverAmount = 0;
        hoverAmountTarget = 1;
        hoverSource = 'cube';
        requestRender();
        applyImageHighlight(hoveredSample);
      } else {
        hoverSource = 'cube';
      }

      showTooltip(event.clientX, event.clientY, nearest.hex);
    }

    function handleCanvasClick(event) {
      if (dragMoved || !hoveredHex || isDragging) return;
      const hex = hoveredHex;
      dragMoved = false;
      copyToClipboard(hex)
        .then(() => indicateCopied(hex, event.clientX, event.clientY))
        .catch(() => {
          showTooltip(event.clientX, event.clientY, 'Clipboard blocked');
          clearTimeout(tooltipCopyTimeout);
          tooltipCopyTimeout = setTimeout(() => {
            tooltipCopyTimeout = null;
            if (hoveredHex) {
              showTooltip(tooltipPosition.x, tooltipPosition.y, hoveredHex);
            } else {
              hideTooltip();
            }
          }, 900);
        });
    }

    function handleImageHover(event) {
      if (!loadedImage || !imageImageData || !samples.length) return;
      const coords = getCanvasPointer(event, imageCanvas);
      if (!coords) {
        clearHover(true, 'image');
        return;
      }
      const { x, y } = coords;
      if (!isWithinImageRegion(x, y)) {
        clearHover(true, 'image');
        return;
      }
      const color = getPixelColorAt(Math.floor(x), Math.floor(y));
      if (!color) {
        clearHover(true, 'image');
        return;
      }
      const lab = rgbToLab(color.r, color.g, color.b);
      const nearestSample = findNearestSampleByLab(lab);
      if (!nearestSample) {
        clearHover(true, 'image');
        return;
      }

      if (hoveredSample !== nearestSample || hoverSource !== 'image') {
        hoveredSample = nearestSample;
        hoveredHex = rgbToHex(nearestSample.rgb);
        hoverAmount = 0;
        hoverAmountTarget = 1;
        hoverSource = 'image';
        requestRender();
        applyImageHighlight(nearestSample);
      } else {
        hoverSource = 'image';
      }

      showTooltip(event.clientX, event.clientY, hoveredHex);
    }

    function handleImageLeave() {
      clearHover(true, 'image');
    }

    function clearHover(shouldRedraw = true, sourceFilter = null) {
      if (sourceFilter && hoverSource !== sourceFilter) {
        return;
      }
      if (hoveredSample) {
        hoveredSample = null;
        hoveredHex = '';
        hoverAmountTarget = 0;
        hoverSource = null;
        if (shouldRedraw) requestRender();
      } else {
        hoverSource = null;
      }
      if (highlightActive) {
        restoreBaseImage();
      }
      hideTooltip();
    }

    function getCanvasPointer(event, canvas) {
      const rect = canvas.getBoundingClientRect();
      if (!rect.width || !rect.height) return null;
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return {
        x: (event.clientX - rect.left) * scaleX,
        y: (event.clientY - rect.top) * scaleY
      };
    }

    function isWithinImageRegion(x, y) {
      return (
        x >= imageDrawRegion.x &&
        x <= imageDrawRegion.x + imageDrawRegion.width &&
        y >= imageDrawRegion.y &&
        y <= imageDrawRegion.y + imageDrawRegion.height
      );
    }

    function getPixelColorAt(x, y) {
      if (!imageImageData) return null;
      if (x < 0 || y < 0 || x >= imageCanvas.width || y >= imageCanvas.height) return null;
      const idx = (y * imageCanvas.width + x) * 4;
      const data = imageImageData.data;
      return {
        r: data[idx],
        g: data[idx + 1],
        b: data[idx + 2],
        a: data[idx + 3]
      };
    }

    function findNearestSampleByLab(targetLab) {
      if (!samples.length) return null;
      let nearest = null;
      let minDelta = Infinity;
      for (const sample of samples) {
        const delta = labDistance(sample.lab, targetLab);
        if (delta < minDelta) {
          minDelta = delta;
          nearest = sample;
        }
      }
      return nearest;
    }

    function labDistance(labA, labB) {
      const dL = labA.L - labB.L;
      const da = labA.a - labB.a;
      const db = labA.b - labB.b;
      return Math.sqrt(dL * dL + da * da + db * db);
    }

    function applyImageHighlight(sample) {
      if (!loadedImage || !imageImageData || !imageLabBuffer || !highlightImageData) return;
      if (highlightActive && lastHighlightSample === sample) {
        return;
      }
      const src = imageImageData.data;
      const dest = highlightImageData.data;
      const labBuffer = imageLabBuffer;
      const { L, a, b } = sample.lab;
      const threshold = highlightTolerance;
      for (let i = 0, j = 0; i < src.length; i += 4, j += 3) {
        const dL = labBuffer[j] - L;
        const da = labBuffer[j + 1] - a;
        const db = labBuffer[j + 2] - b;
        const delta = Math.sqrt(dL * dL + da * da + db * db);
        if (delta <= threshold) {
          dest[i] = src[i];
          dest[i + 1] = src[i + 1];
          dest[i + 2] = src[i + 2];
          dest[i + 3] = src[i + 3];
        } else {
          dest[i] = src[i] * DIM_FACTOR;
          dest[i + 1] = src[i + 1] * DIM_FACTOR;
          dest[i + 2] = src[i + 2] * DIM_FACTOR;
          dest[i + 3] = src[i + 3];
        }
      }
      imageCtx.putImageData(highlightImageData, 0, 0);
      highlightActive = true;
      lastHighlightSample = sample;
    }

    function restoreBaseImage() {
      if (!imageImageData) return;
      imageCtx.putImageData(imageImageData, 0, 0);
      highlightActive = false;
      lastHighlightSample = null;
    }

    function copyToClipboard(text) {
      if (navigator.clipboard?.writeText) {
        return navigator.clipboard.writeText(text);
      }
      return new Promise((resolve, reject) => {
        const input = document.createElement('input');
        input.value = text;
        document.body.appendChild(input);
        input.select();
        input.setSelectionRange(0, text.length);
        try {
          document.execCommand('copy');
          resolve();
        } catch (error) {
          reject(error);
        } finally {
          document.body.removeChild(input);
        }
      });
    }

    function indicateCopied(hex, x, y) {
      showTooltip(x, y, `${hex} copied`);
      clearTimeout(tooltipCopyTimeout);
      tooltipCopyTimeout = setTimeout(() => {
        tooltipCopyTimeout = null;
        if (hoveredHex) {
          showTooltip(tooltipPosition.x, tooltipPosition.y, hoveredHex);
        } else {
          hideTooltip();
        }
      }, 900);
    }

    function showTooltip(x, y, text) {
      tooltipPosition = { x, y };
      tooltip.textContent = text;
      const offset = 14;
      let left = x + offset;
      let top = y + offset;
      const padding = 8;
      const maxLeft = window.innerWidth - padding;
      const maxTop = window.innerHeight - padding;
      tooltip.style.left = `${Math.max(padding, Math.min(left, maxLeft))}px`;
      tooltip.style.top = `${Math.max(padding, Math.min(top, maxTop))}px`;
      tooltip.classList.add('visible');
    }

    function hideTooltip() {
      tooltip.classList.remove('visible');
      clearTimeout(tooltipCopyTimeout);
      tooltipCopyTimeout = null;
    }

    function animationLoop(timestamp = 0) {
      requestAnimationFrame(animationLoop);
      if (!lastFrameTime) lastFrameTime = timestamp;

      let dirty = needsRender;
      const rotX = approach(rotation.x, targetRotation.x, ROTATION_EASING);
      const rotY = approach(rotation.y, targetRotation.y, ROTATION_EASING);
      const zoomStep = approach(zoom, targetZoom, ZOOM_EASING);
      const hoverStep = approach(hoverAmount, hoverAmountTarget, HOVER_EASING);

      if (rotX.changed) {
        rotation.x = rotX.value;
        dirty = true;
      }
      if (rotY.changed) {
        rotation.y = rotY.value;
        dirty = true;
      }
      if (zoomStep.changed) {
        zoom = zoomStep.value;
        dirty = true;
      }
      if (hoverStep.changed) {
        hoverAmount = hoverStep.value;
        dirty = true;
      }

      if (dirty) {
        drawSpace();
        needsRender = false;
      }
    }

    function approach(current, target, easing) {
      if (Math.abs(target - current) < 0.0005) {
        return { value: target, changed: current !== target };
      }
      const value = current + (target - current) * easing;
      return { value, changed: true };
    }

    function requestRender() {
      needsRender = true;
    }

    function setColorUiVisible(isVisible) {
      if (cubeSection) cubeSection.classList.toggle('hidden', !isVisible);
      if (optionsSection) optionsSection.classList.toggle('hidden', !isVisible);
      resetButton.classList.toggle('hidden', !isVisible);
      if (isVisible) {
        requestAnimationFrame(() => {
          if (resizeCanvas(spaceCanvas)) {
            requestRender();
          }
          requestRender();
        });
      }
    }

    function handleImageClick(event) {
      if (!loadedImage) {
        fileInput?.click();
        return;
      }
      const coords = getCanvasPointer(event, imageCanvas);
      if (!coords || !isWithinImageRegion(coords.x, coords.y)) {
        return;
      }
      const color = getPixelColorAt(Math.floor(coords.x), Math.floor(coords.y));
      if (!color) return;
      const hex = rgbToHex([color.r, color.g, color.b]);
      hoveredHex = hex;
      copyToClipboard(hex)
        .then(() => indicateCopied(hex, event.clientX, event.clientY))
        .catch(() => indicateCopied(hex, event.clientX, event.clientY));
    }

    function handlePreviewKey(event) {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        if (!loadedImage) {
          fileInput?.click();
        } else if (hoveredSample) {
          const hex = hoveredHex || rgbToHex(hoveredSample.rgb);
          const rect = imageCanvas.getBoundingClientRect();
          const clientX = rect.left + rect.width / 2;
          const clientY = rect.top + rect.height / 2;
          copyToClipboard(hex)
            .then(() => indicateCopied(hex, clientX, clientY))
            .catch(() => indicateCopied(hex, clientX, clientY));
        } else {
          fileInput?.click();
        }
      }
    }

    function handleSampleChange() {
      const nextValue = parseInt(sampleSlider.value, 10);
      if (!Number.isFinite(nextValue)) return;
      sampleTarget = nextValue;
      syncSampleLabel();
      resampleImage();
    }

    function syncSampleLabel() {
      if (sampleCountLabel) {
        sampleCountLabel.textContent = sampleTarget.toLocaleString();
      }
    }

    function resampleImage() {
      if (!loadedImage) return;
      samples = sampleImage(loadedImage);
      clearHover(false);
      requestRender();
    }

    function handleToleranceChange() {
      const nextValue = parseInt(toleranceSlider.value, 10);
      if (!Number.isFinite(nextValue)) return;
      highlightTolerance = nextValue;
      syncToleranceLabel();
      if (hoveredSample) {
        applyImageHighlight(hoveredSample);
      }
    }

    function syncToleranceLabel() {
      if (toleranceLabel) {
        toleranceLabel.textContent = `${highlightTolerance} ΔE`;
      }
    }

    function handleAdjustmentChange(type) {
      if (type === 'brightness' && brightnessSlider) {
        const value = parseInt(brightnessSlider.value, 10);
        if (Number.isFinite(value)) {
          imageAdjustments.brightness = value;
        }
      } else if (type === 'contrast' && contrastSlider) {
        const value = parseInt(contrastSlider.value, 10);
        if (Number.isFinite(value)) {
          imageAdjustments.contrast = value;
        }
      } else if (type === 'saturation' && saturationSlider) {
        const value = parseInt(saturationSlider.value, 10);
        if (Number.isFinite(value)) {
          imageAdjustments.saturation = value;
        }
      }
      syncAdjustmentLabels();
      if (loadedImage) {
        redrawImage();
        resampleImage();
      }
    }

    function resetAdjustments() {
      imageAdjustments = { ...DEFAULT_ADJUSTMENTS };
      if (brightnessSlider) brightnessSlider.value = String(DEFAULT_ADJUSTMENTS.brightness);
      if (contrastSlider) contrastSlider.value = String(DEFAULT_ADJUSTMENTS.contrast);
      if (saturationSlider) saturationSlider.value = String(DEFAULT_ADJUSTMENTS.saturation);
      syncAdjustmentLabels();
      if (loadedImage) {
        redrawImage();
        resampleImage();
      }
    }

    function syncAdjustmentLabels() {
      if (brightnessLabel) {
        brightnessLabel.textContent = formatSigned(imageAdjustments.brightness);
      }
      if (contrastLabel) {
        contrastLabel.textContent = formatSigned(imageAdjustments.contrast);
      }
      if (saturationLabel) {
        saturationLabel.textContent = `${imageAdjustments.saturation}%`;
      }
    }

    function formatNumber(value) {
      if (Number.isInteger(value)) return `${value}`;
      return value.toFixed(2).replace(/\.?0+$/, '');
    }

    function formatSigned(value) {
      if (value > 0) return `+${formatNumber(value)}`;
      if (value < 0) return `${formatNumber(value)}`;
      return '0';
    }

    function formatPercentLabel(value) {
      return `${formatSigned(value)}%`;
    }

    function formatDegreeLabel(value) {
      return `${formatSigned(value)}°`;
    }

    function renderSpaceAdjustmentControls() {
      if (!spaceAdjustmentsContainer || !spaceSelect) return;
      const mode = spaceSelect.value;
      const descriptor = colorSpaceAdjustmentDefinitions[mode];
      if (!descriptor) {
        if (spaceAdjustmentsBlock) {
          spaceAdjustmentsBlock.classList.add('hidden');
        }
        spaceAdjustmentsContainer.innerHTML = '';
        return;
      }
      spaceAdjustmentsBlock?.classList.remove('hidden');
      if (spaceAdjustmentsTitle) {
        spaceAdjustmentsTitle.textContent = descriptor.title;
      }
      const state = ensureSpaceAdjustmentState(mode);
      spaceAdjustmentsContainer.innerHTML = '';
      spaceAxisElements.clear();
      descriptor.axes.forEach((axis) => {
        const value = clampAxisValue(state[axis.id] ?? axis.defaultValue ?? 0, axis);
        state[axis.id] = value;
        const control = document.createElement('label');
        control.className = 'sub-control';
        const title = document.createElement('span');
        title.className = 'sub-control-title';
        title.textContent = axis.label;
        const rangeWrapper = document.createElement('div');
        rangeWrapper.className = 'range-input';
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = String(axis.min);
        slider.max = String(axis.max);
        slider.step = String(axis.step ?? 1);
        const sliderId = `space-axis-${mode}-${axis.id}`;
        slider.id = sliderId;
        slider.value = String(value);
        slider.dataset.space = mode;
        slider.dataset.axis = axis.id;
        slider.addEventListener('input', handleSpaceAxisInput);
        const output = document.createElement('output');
        output.setAttribute('for', sliderId);
        output.textContent = formatAxisValue(axis, value);
        rangeWrapper.appendChild(slider);
        rangeWrapper.appendChild(output);
        control.appendChild(title);
        control.appendChild(rangeWrapper);
        spaceAdjustmentsContainer.appendChild(control);
        spaceAxisElements.set(axisKey(mode, axis.id), { axis, slider, output });
      });
    }

    function handleSpaceAxisInput(event) {
      const slider = event.currentTarget;
      const mode = slider.dataset.space;
      const axisId = slider.dataset.axis;
      if (!mode || !axisId) return;
      const descriptor = colorSpaceAdjustmentDefinitions[mode];
      if (!descriptor) return;
      const axis = descriptor.axes.find((entry) => entry.id === axisId);
      if (!axis) return;
      const value = clampAxisValue(parseFloat(slider.value), axis);
      const state = ensureSpaceAdjustmentState(mode);
      state[axisId] = value;
      const key = axisKey(mode, axisId);
      const entry = spaceAxisElements.get(key);
      if (entry?.output) {
        entry.output.textContent = formatAxisValue(axis, value);
      }
      handleSpaceAdjustmentChange();
    }

    function handleSpaceAdjustmentChange() {
      if (loadedImage) {
        redrawImage();
        resampleImage();
      } else {
        requestRender();
      }
    }

    function resetSpaceAdjustmentsForCurrentMode() {
      if (!spaceSelect) return;
      const mode = spaceSelect.value;
      const descriptor = colorSpaceAdjustmentDefinitions[mode];
      if (!descriptor) return;
      const state = ensureSpaceAdjustmentState(mode);
      let changed = false;
      descriptor.axes.forEach((axis) => {
        const defaultValue = axis.defaultValue ?? 0;
        if (state[axis.id] !== defaultValue) {
          state[axis.id] = defaultValue;
          changed = true;
        }
      });
      renderSpaceAdjustmentControls();
      if (changed) {
        handleSpaceAdjustmentChange();
      }
    }

    function ensureSpaceAdjustmentState(mode) {
      if (!spaceAdjustmentState[mode]) {
        const descriptor = colorSpaceAdjustmentDefinitions[mode];
        const defaults = {};
        if (descriptor) {
          descriptor.axes.forEach((axis) => {
            defaults[axis.id] = axis.defaultValue ?? 0;
          });
        }
        spaceAdjustmentState[mode] = defaults;
      }
      return spaceAdjustmentState[mode];
    }

    function clampAxisValue(value, axis) {
      if (!Number.isFinite(value)) {
        return axis.defaultValue ?? 0;
      }
      return clamp(value, axis.min, axis.max);
    }

    function formatAxisValue(axis, value) {
      if (typeof axis.formatter === 'function') {
        return axis.formatter(value);
      }
      return formatSigned(value);
    }

    function getSpaceAdjustmentDeltas(mode) {
      const descriptor = colorSpaceAdjustmentDefinitions[mode];
      if (!descriptor) {
        return { deltas: null, hasAdjustments: false };
      }
      const state = ensureSpaceAdjustmentState(mode);
      const deltas = {};
      let hasAdjustments = false;
      descriptor.axes.forEach((axis) => {
        const value = clampAxisValue(state[axis.id] ?? axis.defaultValue ?? 0, axis);
        state[axis.id] = value;
        const delta = typeof axis.toDelta === 'function' ? axis.toDelta(value) : value;
        deltas[axis.id] = delta;
        if (Math.abs(delta) > (axis.epsilon ?? 1e-4)) {
          hasAdjustments = true;
        }
      });
      return { deltas, hasAdjustments };
    }

    function axisKey(mode, axisId) {
      return `${mode}-${axisId}`;
    }

    function rgbToLab(r, g, b) {
      const [x, y, z] = rgbToXyz(r, g, b);
      return xyzToLab(x, y, z);
    }

    function rgbToXyz(r, g, b) {
      const sr = pivotRgb(r / 255);
      const sg = pivotRgb(g / 255);
      const sb = pivotRgb(b / 255);
      const x = sr * 0.4124564 + sg * 0.3575761 + sb * 0.1804375;
      const y = sr * 0.2126729 + sg * 0.7151522 + sb * 0.0721750;
      const z = sr * 0.0193339 + sg * 0.1191920 + sb * 0.9503041;
      return [x, y, z];
    }

    function xyzToLab(x, y, z) {
      const refX = 0.95047;
      const refY = 1.0;
      const refZ = 1.08883;
      const fx = pivotXyz(x / refX);
      const fy = pivotXyz(y / refY);
      const fz = pivotXyz(z / refZ);
      const L = 116 * fy - 16;
      const a = 500 * (fx - fy);
      const b = 200 * (fy - fz);
      return { L, a, b };
    }

    function labToLch(L, a, b) {
      const C = Math.sqrt(a * a + b * b);
      let h = Math.atan2(b, a) * (180 / Math.PI);
      if (h < 0) h += 360;
      return { L, C, h };
    }

    function wrapDegrees(value) {
      if (!Number.isFinite(value)) return 0;
      let wrapped = value % 360;
      if (wrapped < 0) wrapped += 360;
      return wrapped;
    }

    function lchToLab(L, C, h) {
      const hr = (h * Math.PI) / 180;
      return {
        L,
        a: Math.cos(hr) * C,
        b: Math.sin(hr) * C
      };
    }

    function labToRgb(L, a, b) {
      const [x, y, z] = labToXyz(L, a, b);
      return xyzToRgb(x, y, z);
    }

    function labToXyz(L, a, b) {
      const refX = 0.95047;
      const refY = 1.0;
      const refZ = 1.08883;
      const epsilon = 0.008856;
      const kappa = 903.3;

      const fy = (L + 16) / 116;
      const fx = fy + a / 500;
      const fz = fy - b / 200;

      const fx3 = fx ** 3;
      const fy3 = fy ** 3;
      const fz3 = fz ** 3;

      const xr = fx3 > epsilon ? fx3 : (116 * fx - 16) / kappa;
      const yr = L > (kappa * epsilon) ? fy3 : L / kappa;
      const zr = fz3 > epsilon ? fz3 : (116 * fz - 16) / kappa;

      return [xr * refX, yr * refY, zr * refZ];
    }

    function xyzToRgb(x, y, z) {
      let r = x * 3.2404542 + y * -1.5371385 + z * -0.4985314;
      let g = x * -0.9692660 + y * 1.8760108 + z * 0.0415560;
      let b = x * 0.0556434 + y * -0.2040259 + z * 1.0572252;

      r = srgbFromLinear(r);
      g = srgbFromLinear(g);
      b = srgbFromLinear(b);

      if (![r, g, b].every(Number.isFinite)) return null;

      return [
        Math.round(clamp(r * 255, 0, 255)),
        Math.round(clamp(g * 255, 0, 255)),
        Math.round(clamp(b * 255, 0, 255))
      ];
    }

    function xyzToXyy(x, y, z) {
      const sum = x + y + z;
      if (sum === 0) {
        return { x: 0, y: 0, Y: 0 };
      }
      return {
        x: x / sum,
        y: y / sum,
        Y: y
      };
    }

    function xyyToXyz(xChromaticity, yChromaticity, Y) {
      if (yChromaticity <= 0) {
        return { x: 0, y: 0, z: 0 };
      }
      const X = (Y / yChromaticity) * xChromaticity;
      const Z = (Y / yChromaticity) * (1 - xChromaticity - yChromaticity);
      return { x: X, y: Y, z: Z };
    }

    function rgbToLinearRgb(r, g, b) {
      return [pivotRgb(r), pivotRgb(g), pivotRgb(b)];
    }

    function linearRgbToSrgb(r, g, b) {
      return [
        Math.round(clamp(srgbFromLinear(r), 0, 1) * 255),
        Math.round(clamp(srgbFromLinear(g), 0, 1) * 255),
        Math.round(clamp(srgbFromLinear(b), 0, 1) * 255)
      ];
    }

    function rgbToHsl(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h = 0;
      const l = (max + min) / 2;
      const d = max - min;
      let s = 0;
      if (d !== 0) {
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h *= 60;
      }
      return { h, s, l };
    }

    function rgbToHsv(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const d = max - min;
      let h = 0;
      const v = max;
      const s = max === 0 ? 0 : d / max;
      if (d !== 0) {
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h *= 60;
      }
      return { h, s, v };
    }

    function hslToRgb(h, s, l) {
      h = ((h % 360) + 360) % 360;
      const c = (1 - Math.abs(2 * l - 1)) * s;
      const hp = h / 60;
      const x = c * (1 - Math.abs((hp % 2) - 1));
      let r1 = 0, g1 = 0, b1 = 0;
      if (hp >= 0 && hp < 1) {
        r1 = c; g1 = x; b1 = 0;
      } else if (hp >= 1 && hp < 2) {
        r1 = x; g1 = c; b1 = 0;
      } else if (hp >= 2 && hp < 3) {
        r1 = 0; g1 = c; b1 = x;
      } else if (hp >= 3 && hp < 4) {
        r1 = 0; g1 = x; b1 = c;
      } else if (hp >= 4 && hp < 5) {
        r1 = x; g1 = 0; b1 = c;
      } else if (hp >= 5 && hp < 6) {
        r1 = c; g1 = 0; b1 = x;
      }
      const m = l - c / 2;
      return [
        Math.round(clamp((r1 + m) * 255, 0, 255)),
        Math.round(clamp((g1 + m) * 255, 0, 255)),
        Math.round(clamp((b1 + m) * 255, 0, 255))
      ];
    }

    function hsvToRgb(h, s, v) {
      h = ((h % 360) + 360) % 360;
      const c = v * s;
      const hp = h / 60;
      const x = c * (1 - Math.abs((hp % 2) - 1));
      let r1 = 0, g1 = 0, b1 = 0;
      if (hp >= 0 && hp < 1) {
        r1 = c; g1 = x; b1 = 0;
      } else if (hp >= 1 && hp < 2) {
        r1 = x; g1 = c; b1 = 0;
      } else if (hp >= 2 && hp < 3) {
        r1 = 0; g1 = c; b1 = x;
      } else if (hp >= 3 && hp < 4) {
        r1 = 0; g1 = x; b1 = c;
      } else if (hp >= 4 && hp < 5) {
        r1 = x; g1 = 0; b1 = c;
      } else if (hp >= 5 && hp < 6) {
        r1 = c; g1 = 0; b1 = x;
      }
      const m = v - c;
      return [
        Math.round(clamp((r1 + m) * 255, 0, 255)),
        Math.round(clamp((g1 + m) * 255, 0, 255)),
        Math.round(clamp((b1 + m) * 255, 0, 255))
      ];
    }

    function rgbToYcbcr(r, g, b) {
      const R = r / 255;
      const G = g / 255;
      const B = b / 255;
      const y = 0.299 * R + 0.587 * G + 0.114 * B;
      const cb = -0.168736 * R - 0.331264 * G + 0.5 * B + 0.5;
      const cr = 0.5 * R - 0.418688 * G - 0.081312 * B + 0.5;
      return { y, cb, cr };
    }

    function ycbcrToRgb(y, cb, cr) {
      const r = y + 1.402 * (cr - 0.5);
      const g = y - 0.344136 * (cb - 0.5) - 0.714136 * (cr - 0.5);
      const b = y + 1.772 * (cb - 0.5);
      return [
        Math.round(clamp(r, 0, 1) * 255),
        Math.round(clamp(g, 0, 1) * 255),
        Math.round(clamp(b, 0, 1) * 255)
      ];
    }

    function rgbToOklab(r, g, b) {
      const R = pivotRgb(r / 255);
      const G = pivotRgb(g / 255);
      const B = pivotRgb(b / 255);

      const l = 0.4122214708 * R + 0.5363325363 * G + 0.0514459929 * B;
      const m = 0.2119034982 * R + 0.6806995451 * G + 0.1073969566 * B;
      const s = 0.0883024619 * R + 0.2817188376 * G + 0.6299787005 * B;

      const l_ = Math.cbrt(l);
      const m_ = Math.cbrt(m);
      const s_ = Math.cbrt(s);

      const L = 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_;
      const a = 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_;
      const b2 = 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_;

      return { L, a, b: b2 };
    }

    function oklabToOklch(L, a, b) {
      const C = Math.sqrt(a * a + b * b);
      const h = wrapDegrees((Math.atan2(b, a) * 180) / Math.PI);
      return { L, C, h };
    }

    function oklchToOklab(L, C, h) {
      const hr = (h * Math.PI) / 180;
      return {
        L,
        a: Math.cos(hr) * C,
        b: Math.sin(hr) * C
      };
    }

    function oklabToRgb(L, a, b) {
      const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
      const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
      const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

      const l = l_ * l_ * l_;
      const m = m_ * m_ * m_;
      const s = s_ * s_ * s_;

      let R = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
      let G = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
      let B = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

      R = srgbFromLinear(R);
      G = srgbFromLinear(G);
      B = srgbFromLinear(B);

      return [
        Math.round(clamp(R * 255, 0, 255)),
        Math.round(clamp(G * 255, 0, 255)),
        Math.round(clamp(B * 255, 0, 255))
      ];
    }

    function srgbFromLinear(value) {
      const v = clamp(value, 0, 1);
      return v <= 0.0031308 ? 12.92 * v : 1.055 * Math.pow(v, 1 / 2.4) - 0.055;
    }

    function pivotRgb(value) {
      return value <= 0.04045 ? value / 12.92 : Math.pow((value + 0.055) / 1.055, 2.4);
    }

    function pivotXyz(value) {
      const epsilon = 0.008856;
      const kappa = 903.3;
      return value > epsilon ? Math.cbrt(value) : (kappa * value + 16) / 116;
    }

    function coordsToColor(mode, coords) {
      if (mode === 'rgb') {
        return [
          Math.round(coords.x * 255),
          Math.round(coords.y * 255),
          Math.round(coords.z * 255)
        ];
      }
      if (mode === 'lab') {
        const lab = {
          L: coords.z * 100,
          a: coords.x * 255 - 128,
          b: coords.y * 255 - 128
        };
        return labToRgb(lab.L, lab.a, lab.b);
      }
      if (mode === 'lch') {
        const lab = lchToLab(coords.z * 100, coords.x * MAX_CHROMA, coords.y * 360);
        return labToRgb(lab.L, lab.a, lab.b);
      }
      if (mode === 'linrgb') {
        const rLin = clamp(coords.x, 0, 1);
        const gLin = clamp(coords.y, 0, 1);
        const bLin = clamp(coords.z, 0, 1);
        return [
          Math.round(srgbFromLinear(rLin) * 255),
          Math.round(srgbFromLinear(gLin) * 255),
          Math.round(srgbFromLinear(bLin) * 255)
        ];
      }
      if (mode === 'hsl') {
        const h = clamp(coords.x, 0, 1) * 360;
        const s = clamp(coords.y, 0, 1);
        const l = clamp(coords.z, 0, 1);
        return hslToRgb(h, s, l);
      }
      if (mode === 'hsv') {
        const h = clamp(coords.x, 0, 1) * 360;
        const s = clamp(coords.y, 0, 1);
        const v = clamp(coords.z, 0, 1);
        return hsvToRgb(h, s, v);
      }
      if (mode === 'ycbcr') {
        const y = clamp(coords.x, 0, 1);
        const cb = clamp(coords.y, 0, 1);
        const cr = clamp(coords.z, 0, 1);
        const r = y + 1.402 * (cr - 0.5);
        const g = y - 0.344136 * (cb - 0.5) - 0.714136 * (cr - 0.5);
        const b = y + 1.772 * (cb - 0.5);
        return [
          Math.round(clamp(r, 0, 1) * 255),
          Math.round(clamp(g, 0, 1) * 255),
          Math.round(clamp(b, 0, 1) * 255)
        ];
      }
      if (mode === 'xyz') {
        const X = clamp(coords.x, 0, 1) * 0.95047;
        const Y = clamp(coords.y, 0, 1) * 1.0;
        const Z = clamp(coords.z, 0, 1) * 1.08883;
        return labToRgb(...xyzToLab(X, Y, Z));
      }
      if (mode === 'xyy') {
        const x = clamp(coords.x, 0, 1);
        const y = clamp(coords.y, 0, 1);
        const Y = clamp(coords.z, 0, 1);
        if (y === 0) return [0, 0, 0];
        const X = (Y / y) * x;
        const Z = (Y / y) * (1 - x - y);
        return labToRgb(...xyzToLab(X, Y, Z));
      }
      if (mode === 'oklab') {
        const L = clamp(coords.z, 0, 1);
        const a = (clamp(coords.x, 0, 1) - 0.5) * (2 * OK_MAX_CHROMA);
        const b = (clamp(coords.y, 0, 1) - 0.5) * (2 * OK_MAX_CHROMA);
        return oklabToRgb(L, a, b);
      }
      if (mode === 'oklch') {
        const L = clamp(coords.z, 0, 1);
        const C = clamp(coords.x, 0, 1) * OK_MAX_CHROMA;
        const h = clamp(coords.y, 0, 1) * 360;
        const hr = (h * Math.PI) / 180;
        const a = Math.cos(hr) * C;
        const b = Math.sin(hr) * C;
        return oklabToRgb(L, a, b);
      }
      return null;
    }

    function createReferenceGrid(steps) {
      const points = [];
      if (steps < 2) return [{ x: 0.5, y: 0.5, z: 0.5 }];
      const max = steps - 1;
      for (let ix = 0; ix < steps; ix++) {
        for (let iy = 0; iy < steps; iy++) {
          for (let iz = 0; iz < steps; iz++) {
            points.push({
              x: ix / max,
              y: iy / max,
              z: iz / max
            });
          }
        }
      }
      return points;
    }

    function rgbToHex(rgb) {
      const toHex = (value) => {
        const safe = Math.round(clamp(value, 0, 255));
        return safe.toString(16).padStart(2, '0');
      };
      return `#${toHex(rgb[0])}${toHex(rgb[1])}${toHex(rgb[2])}`.toUpperCase();
    }
  </script>
</body>
</html>

