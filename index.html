<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="fediverse:creator" content="@bitbraindev@mastodon.gamedev.place">
  <title>niji · color space visualiser</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Baloo+2:wght@400;500;600&display=swap');

    :root {
      color-scheme: dark;
      font-family: "Baloo 2", "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background-color: #0a0503;
      color: #fff5ec;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at 15% 20%, rgba(255, 183, 131, 0.25), transparent 40%),
        radial-gradient(circle at 80% 0%, rgba(255, 137, 181, 0.18), transparent 45%),
        #0a0503;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      padding: 2.5rem 1.5rem 2rem;
    }

    header {
      width: 100%;
    }

    header h1 {
      margin: 0;
      font-size: clamp(2.3rem, 4vw, 3.3rem);
      letter-spacing: -0.02em;
      font-weight: 600;
      background: linear-gradient(90deg, #ff8ba7, #ffd166, #f4a259, #ff6b6b);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      filter: saturate(110%);
    }

    header p {
      margin: 0.35rem 0 0;
      color: #ffe3d2;
      font-size: 1rem;
    }

    footer {
      width: 100%;
      margin: auto;
      text-align: center;
      color: #ffb8de;
      font-size: 0.9rem;
    }

    footer a {
      color: #ffd2ff;
      text-decoration: none;
    }

    footer a:hover {
      color: #ffe4ff;
      text-decoration: underline;
    }

    main {
      width: 100%;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .visual-panels {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1.5rem;
      align-items: start;
    }

    .visual-panels > * {
      min-width: 0;
    }

    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem 1.5rem;
      align-items: flex-end;
    }

    .control-block {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-size: 0.95rem;
      color: #ffe5c9;
      flex: 1 1 260px;
      min-width: 220px;
    }

    .preview-section {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    figure {
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    input[type="file"],
    select,
    input[type="range"] {
      border: none;
      border-radius: 1.1rem;
      background: rgba(255, 255, 255, 0.12);
      color: inherit;
      padding: 0.6rem 0.85rem;
      font: inherit;
      min-width: 180px;
      box-shadow: none;
    }

    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      padding: 0;
      background: transparent;
      border-radius: 999px;
      height: auto;
    }

    input[type="range"]::-webkit-slider-runnable-track {
      height: 8px;
      border-radius: 999px;
      background: linear-gradient(90deg, #ffcd70, #ffa36c, #ff7ba5, #ff9770);
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff1d0;
      border: none;
      margin-top: -5px;
      box-shadow: none;
    }

    input[type="range"]::-moz-range-track {
      height: 8px;
      border-radius: 999px;
      background: linear-gradient(90deg, #ffcd70, #ffa36c, #ff7ba5, #ff9770);
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff1d0;
      border: none;
      box-shadow: none;
    }

    .range-input {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .range-input output {
      font-variant-numeric: tabular-nums;
      font-weight: 600;
      color: #ffd5b5;
      min-width: 4rem;
      text-align: right;
    }

    .status-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      justify-content: space-between;
    }

    .status {
      font-size: 0.92rem;
      color: #ffcfad;
      flex: 1 1 auto;
    }

    .reset-button {
      appearance: none;
      border: none;
      border-radius: 1rem;
      padding: 0.55rem 1.4rem;
      background: linear-gradient(100deg, #ffaf7a, #ff6f91);
      color: #fff8f1;
      font: inherit;
      font-size: 0.9rem;
      cursor: pointer;
      transition: transform 0.15s ease;
    }

    .reset-button:hover {
      transform: translateY(-1px);
    }

    .cube-row {
      margin: 0;
    }

    .cube-row figure {
      width: 100%;
    }

    figcaption {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #ffdac1;
    }

    canvas {
      width: 100%;
      aspect-ratio: 4 / 3;
      border-radius: 1.3rem;
      background: rgba(27, 12, 8, 0.95);
      box-shadow: none;
    }

    #imageCanvas {
      cursor: pointer;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(27, 12, 8, 0.25));
    }

    #spaceCanvas {
      cursor: grab;
      background: radial-gradient(circle at 35% 20%, rgba(255, 213, 153, 0.35), rgba(27, 12, 8, 0.97));
      aspect-ratio: 3 / 2;
      min-height: clamp(360px, 55vh, 560px);
    }

    #spaceCanvas.dragging {
      cursor: grabbing;
    }

    .hint {
      margin: 0.5rem 0 0;
      color: #ffcfb2;
      font-size: 0.95rem;
      text-align: center;
    }

    .hidden {
      display: none;
    }

    .tooltip {
      position: fixed;
      padding: 0.45rem 0.75rem;
      border-radius: 0.9rem;
      background: rgba(32, 15, 9, 0.96);
      color: #fff0e4;
      font-size: 0.85rem;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.12s ease, transform 0.12s ease;
      z-index: 20;
      box-shadow: none;
    }

    .tooltip.visible {
      opacity: 1;
      transform: translateY(-2px);
    }

    @media (min-width: 1100px) {
      .visual-panels {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 768px) {
      body {
        padding: 1.75rem 1rem 2rem;
      }
    }

    @media (max-width: 520px) {
      .controls-row {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>niji</h1>
    <p>Upload a photo, sample its colors, and place them inside a rotatable RGB/Lab/LCh cube.</p>
  </header>

  <input type="file" accept="image/*" id="fileInput" hidden>

  <main>
    <div class="visual-panels">
      <section class="preview-section">
        <figure>
          <figcaption>Image preview</figcaption>
          <canvas id="imageCanvas" tabindex="0"></canvas>
        </figure>
        <div class="status-row">
          <button type="button" class="reset-button hidden" id="resetButton">Reset</button>
        </div>
      </section>

      <section class="cube-row hidden" id="cubeSection">
        <figure>
          <figcaption>Color cube</figcaption>
          <canvas id="spaceCanvas"></canvas>
        </figure>
      </section>
    </div>

    <section class="controls-row hidden" id="optionsSection">
      <label class="control-block">
        Color space
        <select id="spaceSelect">
          <option value="rgb">RGB</option>
          <option value="lab">Lab</option>
          <option value="lch">LCh</option>
        </select>
      </label>
      <label class="control-block">
        Color samples
        <div class="range-input">
          <input type="range" id="sampleSlider" min="200" max="10000" step="100" value="2000">
          <output id="sampleCountLabel" for="sampleSlider">2,000</output>
        </div>
      </label>
      <label class="control-block">
        Similar color tolerance
        <div class="range-input">
          <input type="range" id="toleranceSlider" min="2" max="50" step="1" value="2">
          <output id="toleranceLabel" for="toleranceSlider">2 ΔE</output>
        </div>
      </label>
    </section>

  </main>

  <footer>
    made by <a rel="me" href="https://mastodon.gamedev.place/@bitbraindev">bitbrain</a> with ❤️
  </footer>

  <script>
    const fileInput = document.getElementById('fileInput');
    const spaceSelect = document.getElementById('spaceSelect');
    const sampleSlider = document.getElementById('sampleSlider');
    const sampleCountLabel = document.getElementById('sampleCountLabel');
    const toleranceSlider = document.getElementById('toleranceSlider');
    const toleranceLabel = document.getElementById('toleranceLabel');
    const imageCanvas = document.getElementById('imageCanvas');
    const resetButton = document.getElementById('resetButton');
    const spaceCanvas = document.getElementById('spaceCanvas');
    const cubeSection = document.getElementById('cubeSection');
    const optionsSection = document.getElementById('optionsSection');
    const imageCtx = imageCanvas.getContext('2d');
    const spaceCtx = spaceCanvas.getContext('2d');
    const sampleCanvas = document.createElement('canvas');
    const sampleCtx = sampleCanvas.getContext('2d');
    const tooltip = document.createElement('div');
    tooltip.className = 'tooltip';
    document.body.appendChild(tooltip);

    const cubeVertices = [
      { x: 0, y: 0, z: 0 },
      { x: 1, y: 0, z: 0 },
      { x: 0, y: 1, z: 0 },
      { x: 1, y: 1, z: 0 },
      { x: 0, y: 0, z: 1 },
      { x: 1, y: 0, z: 1 },
      { x: 0, y: 1, z: 1 },
      { x: 1, y: 1, z: 1 }
    ];

    const cubeEdges = [
      [0, 1], [0, 2], [1, 3], [2, 3],
      [4, 5], [4, 6], [5, 7], [6, 7],
      [0, 4], [1, 5], [2, 6], [3, 7]
    ];

    const axisLabels = {
      rgb: ['R', 'G', 'B'],
      lab: ['a*', 'b*', 'L*'],
      lch: ['C*', 'h°', 'L*']
    };

    const MAX_CHROMA = 150;
    const HOVER_PICK_RADIUS = 9;
    const BASE_POINT_RADIUS = 3;
    const HOVER_RADIUS_DELTA = 4;
    const ROTATION_EASING = 0.18;
    const ZOOM_EASING = 0.16;
    const HOVER_EASING = 0.25;
    const DEFAULT_HIGHLIGHT_DELTA = 2;
    const DIM_FACTOR = 0.14;
    const clamp = (value, min, max) => Math.min(max, Math.max(min, value));

    const referenceGrid = createReferenceGrid(6);

    let loadedImage = null;
    let samples = [];
    let rotation = { x: -0.9, y: 0.9 };
    let targetRotation = { x: rotation.x, y: rotation.y };
    let zoom = 1;
    let targetZoom = 1;
    let isDragging = false;
    let lastPointer = { x: 0, y: 0 };
    let pinchDistance = null;
    let pinchZoomStart = null;
    let projectedSamples = [];
    let hoveredSample = null;
    let hoveredHex = '';
    let tooltipCopyTimeout = null;
    let tooltipPosition = { x: 0, y: 0 };
    let dragMoved = false;
    let sampleTarget = parseInt(sampleSlider?.value ?? '2000', 10) || 2000;
    let highlightTolerance = parseInt(
      toleranceSlider?.value ?? String(DEFAULT_HIGHLIGHT_DELTA),
      10
    ) || DEFAULT_HIGHLIGHT_DELTA;
    let hoverAmount = 0;
    let hoverAmountTarget = 0;
    let hoverSource = null;
    let needsRender = true;
    let lastFrameTime = 0;
    let imageImageData = null;
    let imageLabBuffer = null;
    let highlightImageData = null;
    let highlightActive = false;
    let lastHighlightSample = null;
    let imageDrawRegion = { x: 0, y: 0, width: 0, height: 0 };

    fileInput.addEventListener('change', handleImageUpload);
    spaceSelect.addEventListener('change', () => {
      clearHover(false);
      requestRender();
    });
    sampleSlider.addEventListener('input', handleSampleChange);
    toleranceSlider?.addEventListener('input', handleToleranceChange);
    imageCanvas.addEventListener('click', handleImageClick);
    imageCanvas.addEventListener('keydown', handlePreviewKey);
    imageCanvas.addEventListener('mousemove', handleImageHover);
    imageCanvas.addEventListener('mouseleave', handleImageLeave);
    resetButton.addEventListener('click', resetImage);

    window.addEventListener('resize', () => {
      const changedImage = resizeCanvas(imageCanvas);
      const changedSpace = resizeCanvas(spaceCanvas);
      if (changedImage) redrawImage();
      if (changedSpace) requestRender();
    });

    spaceCanvas.addEventListener('mousedown', (event) => {
      startDrag(event);
      clearHover(false);
    });
    window.addEventListener('mouseup', endDrag);
    spaceCanvas.addEventListener('mouseleave', () => {
      endDrag();
      clearHover();
    });
    spaceCanvas.addEventListener('mousemove', (event) => {
      dragMove(event);
      handleHover(event);
    });
    spaceCanvas.addEventListener('click', handleCanvasClick);
    spaceCanvas.addEventListener('wheel', adjustZoom, { passive: false });
    spaceCanvas.addEventListener('touchstart', handleTouchStart, { passive: false });
    spaceCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    spaceCanvas.addEventListener('touchend', handleTouchEnd);
    spaceCanvas.addEventListener('touchcancel', handleTouchEnd);

    syncSampleLabel();
    syncToleranceLabel();
    setColorUiVisible(false);
    initializeCanvases();
    drawPlaceholderImage();
    requestAnimationFrame(animationLoop);

    function initializeCanvases() {
      resizeCanvas(imageCanvas);
      resizeCanvas(spaceCanvas);
    }

    function resizeCanvas(canvas) {
      const { width, height } = canvas.getBoundingClientRect();
      if (!width || !height) return false;
      const roundedWidth = Math.round(width);
      const roundedHeight = Math.round(height);
      if (canvas.width !== roundedWidth || canvas.height !== roundedHeight) {
        canvas.width = roundedWidth;
        canvas.height = roundedHeight;
        return true;
      }
      return false;
    }

    function handleImageUpload(event) {
      const file = event.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          loadedImage = img;
          redrawImage();
          samples = sampleImage(img);
          clearHover(false);
          setColorUiVisible(true);
          requestRender();
        };
        img.src = reader.result;
      };
      reader.readAsDataURL(file);
      event.target.value = '';
    }

    function redrawImage() {
      imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
      if (!loadedImage) {
        drawPlaceholderImage();
        return;
      }
      const { width, height } = fitContain(loadedImage.width, loadedImage.height, imageCanvas.width, imageCanvas.height);
      const offsetX = (imageCanvas.width - width) / 2;
      const offsetY = (imageCanvas.height - height) / 2;
      imageCtx.drawImage(loadedImage, offsetX, offsetY, width, height);
      imageDrawRegion = { x: offsetX, y: offsetY, width, height };
      cacheImageData();
      if (hoveredSample) {
        applyImageHighlight(hoveredSample);
      }
    }

    function drawPlaceholderImage() {
      imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
      imageCtx.fillStyle = '#1c0e08';
      imageCtx.fillRect(0, 0, imageCanvas.width, imageCanvas.height);
      imageImageData = null;
      imageLabBuffer = null;
      highlightImageData = null;
      highlightActive = false;
      lastHighlightSample = null;
      imageDrawRegion = { x: 0, y: 0, width: imageCanvas.width, height: imageCanvas.height };
      const step = 28;
      imageCtx.strokeStyle = 'rgba(255, 179, 153, 0.2)';
      imageCtx.lineWidth = 1;
      for (let x = step; x < imageCanvas.width; x += step) {
        imageCtx.beginPath();
        imageCtx.moveTo(x, 0);
        imageCtx.lineTo(x, imageCanvas.height);
        imageCtx.stroke();
      }
      for (let y = step; y < imageCanvas.height; y += step) {
        imageCtx.beginPath();
        imageCtx.moveTo(0, y);
        imageCtx.lineTo(imageCanvas.width, y);
        imageCtx.stroke();
      }
      imageCtx.fillStyle = '#ffbfa3';
      imageCtx.textAlign = 'center';
      imageCtx.textBaseline = 'middle';
      imageCtx.font = '500 14px "Inter", system-ui, sans-serif';
      imageCtx.fillText('Drop a photo here or pick one above', imageCanvas.width / 2, imageCanvas.height / 2);
    }

    function fitContain(srcWidth, srcHeight, maxWidth, maxHeight) {
      const scale = Math.min(maxWidth / srcWidth, maxHeight / srcHeight);
      return {
        width: srcWidth * scale,
        height: srcHeight * scale
      };
    }

    function cacheImageData() {
      if (!loadedImage) {
        imageImageData = null;
        imageLabBuffer = null;
        highlightImageData = null;
        highlightActive = false;
        lastHighlightSample = null;
        return;
      }
      if (!imageCanvas.width || !imageCanvas.height) return;
      imageImageData = imageCtx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
      const pixelCount = imageCanvas.width * imageCanvas.height;
      imageLabBuffer = new Float32Array(pixelCount * 3);
      const data = imageImageData.data;
      for (let i = 0, j = 0; i < data.length; i += 4, j += 3) {
        const lab = rgbToLab(data[i], data[i + 1], data[i + 2]);
        imageLabBuffer[j] = lab.L;
        imageLabBuffer[j + 1] = lab.a;
        imageLabBuffer[j + 2] = lab.b;
      }
      highlightImageData = imageCtx.createImageData(imageCanvas.width, imageCanvas.height);
      highlightActive = false;
      lastHighlightSample = null;
    }

    function resetImage() {
      loadedImage = null;
      samples = [];
      hoverSource = null;
      clearHover(false);
      drawPlaceholderImage();
      setColorUiVisible(false);
      requestRender();
      if (fileInput) fileInput.value = '';
    }

    function sampleImage(image) {
      const maxDimension = 640;
      const largestSide = Math.max(image.width, image.height);
      const scale = Math.min(1, maxDimension / largestSide);
      const w = Math.max(1, Math.round(image.width * scale));
      const h = Math.max(1, Math.round(image.height * scale));

      sampleCanvas.width = w;
      sampleCanvas.height = h;
      sampleCtx.drawImage(image, 0, 0, w, h);

      const data = sampleCtx.getImageData(0, 0, w, h).data;
      const targetSamples = Math.max(50, sampleTarget);
      const stride = Math.max(1, Math.round(Math.sqrt((w * h) / targetSamples)));
      const collected = [];

      for (let y = 0; y < h; y += stride) {
        for (let x = 0; x < w; x += stride) {
          const idx = (y * w + x) * 4;
          const r = data[idx];
          const g = data[idx + 1];
          const b = data[idx + 2];
          const lab = rgbToLab(r, g, b);
          const lch = labToLch(lab.L, lab.a, lab.b);
          collected.push({ rgb: [r, g, b], lab, lch });
        }
      }

      return collected;
    }

    function drawSpace() {
      spaceCtx.clearRect(0, 0, spaceCanvas.width, spaceCanvas.height);
      spaceCtx.fillStyle = '#050912';
      spaceCtx.fillRect(0, 0, spaceCanvas.width, spaceCanvas.height);

      drawBackgroundPoints();
      drawCube();
      drawAxes();
      drawPoints();
    }

    function drawCube() {
      spaceCtx.save();
      spaceCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      spaceCtx.lineWidth = 1;
      cubeEdges.forEach(([start, end]) => {
        const a = project(cubeVertices[start]);
        const b = project(cubeVertices[end]);
        spaceCtx.beginPath();
        spaceCtx.moveTo(a.x, a.y);
        spaceCtx.lineTo(b.x, b.y);
        spaceCtx.stroke();
      });
      spaceCtx.restore();
    }

    function drawAxes() {
      const origin = project({ x: 0, y: 0, z: 0 });
      const axes = {
        x: project({ x: 1, y: 0, z: 0 }),
        y: project({ x: 0, y: 1, z: 0 }),
        z: project({ x: 0, y: 0, z: 1 })
      };

      spaceCtx.save();
      spaceCtx.strokeStyle = 'rgba(59, 130, 246, 0.55)';
      spaceCtx.lineWidth = 1.4;
      Object.values(axes).forEach((axis) => {
        spaceCtx.beginPath();
        spaceCtx.moveTo(origin.x, origin.y);
        spaceCtx.lineTo(axis.x, axis.y);
        spaceCtx.stroke();
      });

      const labels = axisLabels[spaceSelect.value];
      spaceCtx.fillStyle = 'rgba(248, 250, 252, 0.92)';
      spaceCtx.font = '700 20px "Inter", system-ui, sans-serif';
      spaceCtx.textAlign = 'center';
      spaceCtx.textBaseline = 'middle';
      spaceCtx.fillText(labels[0], axes.x.x + 32, axes.x.y + 4);
      spaceCtx.fillText(labels[1], axes.y.x - 4, axes.y.y - 28);
      spaceCtx.fillText(labels[2], axes.z.x - 20, axes.z.y - 22);
      spaceCtx.restore();
    }

    function drawBackgroundPoints() {
      const mode = spaceSelect.value;
      const background = [];
      referenceGrid.forEach((coords) => {
        const rgb = coordsToColor(mode, coords);
        if (!rgb) return;
        const point = project(coords);
        background.push({
          x: point.x,
          y: point.y,
          depth: point.depth,
          rgb
        });
      });
      background.sort((a, b) => a.depth - b.depth);

      spaceCtx.save();
      spaceCtx.globalAlpha = 0.18;
      background.forEach(({ x, y, rgb }) => {
        spaceCtx.beginPath();
        spaceCtx.fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
        spaceCtx.arc(x, y, 2, 0, Math.PI * 2);
        spaceCtx.fill();
      });
      spaceCtx.restore();
    }

    function drawPoints() {
      projectedSamples = [];
      if (!samples.length) return;
      const mode = spaceSelect.value;

      const projected = [];
      for (const sample of samples) {
        const coords = mapSample(sample, mode);
        if (!coords) continue;
        const point = project(coords);
        const entry = {
          x: point.x,
          y: point.y,
          depth: point.depth,
          rgb: sample.rgb,
          sample,
          hex: rgbToHex(sample.rgb),
          isHovered: hoveredSample === sample
        };
        projected.push(entry);
      }

      projectedSamples = projected;
      const sorted = projected.slice().sort((a, b) => a.depth - b.depth);

      spaceCtx.save();
      sorted.forEach(({ x, y, rgb, isHovered }) => {
        const radius = BASE_POINT_RADIUS + (isHovered ? hoverAmount * HOVER_RADIUS_DELTA : 0);
        spaceCtx.beginPath();
        spaceCtx.fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
        spaceCtx.globalAlpha = isHovered ? 1 : 0.92;
        spaceCtx.arc(x, y, radius, 0, Math.PI * 2);
        spaceCtx.fill();
        if (isHovered && hoverAmount > 0.05) {
          spaceCtx.globalAlpha = 0.85;
          spaceCtx.lineWidth = 1.5;
          spaceCtx.strokeStyle = 'rgba(248, 250, 252, 0.8)';
          spaceCtx.beginPath();
          spaceCtx.arc(x, y, radius + 1.5, 0, Math.PI * 2);
          spaceCtx.stroke();
        }
      });
      spaceCtx.restore();
    }

    function mapSample(sample, mode) {
      if (mode === 'rgb') {
        return {
          x: clamp(sample.rgb[0] / 255, 0, 1),
          y: clamp(sample.rgb[1] / 255, 0, 1),
          z: clamp(sample.rgb[2] / 255, 0, 1)
        };
      }
      if (mode === 'lab') {
        return {
          x: clamp((sample.lab.a + 128) / 255, 0, 1),
          y: clamp((sample.lab.b + 128) / 255, 0, 1),
          z: clamp(sample.lab.L / 100, 0, 1)
        };
      }
      if (mode === 'lch') {
        const hue = Number.isFinite(sample.lch.h) ? sample.lch.h : 0;
        return {
          x: clamp(sample.lch.C / MAX_CHROMA, 0, 1),
          y: clamp(hue / 360, 0, 1),
          z: clamp(sample.lch.L / 100, 0, 1)
        };
      }
      return null;
    }

    function project(point) {
      const centered = {
        x: point.x - 0.5,
        y: point.y - 0.5,
        z: point.z - 0.5
      };

      const cosY = Math.cos(rotation.y);
      const sinY = Math.sin(rotation.y);
      let x = centered.x * cosY - centered.z * sinY;
      let z = centered.x * sinY + centered.z * cosY;

      const cosX = Math.cos(rotation.x);
      const sinX = Math.sin(rotation.x);
      let y = centered.y * cosX - z * sinX;
      z = centered.y * sinX + z * cosX;

      const scale = Math.min(spaceCanvas.width, spaceCanvas.height) * 0.55 * zoom;

      return {
        x: x * scale + spaceCanvas.width / 2,
        y: y * scale + spaceCanvas.height / 2,
        depth: z
      };
    }

    function startDrag(event) {
      isDragging = true;
      lastPointer = { x: event.clientX, y: event.clientY };
      spaceCanvas.classList.add('dragging');
      dragMoved = false;
    }

    function dragMove(event) {
      if (!isDragging) return;
      const dx = event.clientX - lastPointer.x;
      const dy = event.clientY - lastPointer.y;
      targetRotation.y += dx * 0.005;
      targetRotation.x += dy * 0.005;
      targetRotation.x = clamp(targetRotation.x, -Math.PI / 2, Math.PI / 2);
      lastPointer = { x: event.clientX, y: event.clientY };
      if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {
        dragMoved = true;
      }
      requestRender();
    }

    function endDrag() {
      isDragging = false;
      spaceCanvas.classList.remove('dragging');
      dragMoved = false;
    }

    function adjustZoom(event) {
      event.preventDefault();
      const delta = -event.deltaY * 0.001;
      targetZoom = clamp(targetZoom * (1 + delta), 0.4, 3);
      requestRender();
    }

    function handleTouchStart(event) {
      clearHover(false);
      if (event.touches.length === 1) {
        isDragging = true;
        lastPointer = { x: event.touches[0].clientX, y: event.touches[0].clientY };
        spaceCanvas.classList.add('dragging');
      } else if (event.touches.length === 2) {
        pinchDistance = getDistance(event.touches[0], event.touches[1]);
        pinchZoomStart = targetZoom;
      }
    }

    function handleTouchMove(event) {
      event.preventDefault();
      if (event.touches.length === 1 && isDragging) {
        const touch = event.touches[0];
        const dx = touch.clientX - lastPointer.x;
        const dy = touch.clientY - lastPointer.y;
        targetRotation.y += dx * 0.005;
        targetRotation.x += dy * 0.005;
        targetRotation.x = clamp(targetRotation.x, -Math.PI / 2, Math.PI / 2);
        lastPointer = { x: touch.clientX, y: touch.clientY };
        requestRender();
      } else if (event.touches.length === 2 && pinchDistance) {
        const newDistance = getDistance(event.touches[0], event.touches[1]);
        const ratio = newDistance / pinchDistance;
        targetZoom = clamp(pinchZoomStart * ratio, 0.4, 3);
        requestRender();
      }
    }

    function handleTouchEnd(event) {
      if (event.touches.length === 0) {
        isDragging = false;
        spaceCanvas.classList.remove('dragging');
        pinchDistance = null;
        pinchZoomStart = null;
        hideTooltip();
      } else if (event.touches.length === 1) {
        lastPointer = { x: event.touches[0].clientX, y: event.touches[0].clientY };
        pinchDistance = null;
        pinchZoomStart = null;
      }
    }

    function getDistance(a, b) {
      const dx = a.clientX - b.clientX;
      const dy = a.clientY - b.clientY;
      return Math.hypot(dx, dy);
    }

    function handleHover(event) {
      if (isDragging || !projectedSamples.length) {
        clearHover(true, 'cube');
        return;
      }
      const rect = spaceCanvas.getBoundingClientRect();
      const pointer = {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
      };

      let nearest = null;
      let minDist = Infinity;
      for (const point of projectedSamples) {
        const dx = point.x - pointer.x;
        const dy = point.y - pointer.y;
        const dist = Math.hypot(dx, dy);
        if (dist <= HOVER_PICK_RADIUS && dist < minDist) {
          minDist = dist;
          nearest = point;
        }
      }

      if (!nearest) {
        clearHover(true, 'cube');
        return;
      }

      if (hoveredSample !== nearest.sample || hoverSource !== 'cube') {
        hoveredSample = nearest.sample;
        hoveredHex = nearest.hex;
        hoverAmount = 0;
        hoverAmountTarget = 1;
        hoverSource = 'cube';
        requestRender();
        applyImageHighlight(hoveredSample);
      } else {
        hoverSource = 'cube';
      }

      showTooltip(event.clientX, event.clientY, nearest.hex);
    }

    function handleCanvasClick(event) {
      if (dragMoved || !hoveredHex || isDragging) return;
      const hex = hoveredHex;
      dragMoved = false;
      copyToClipboard(hex)
        .then(() => indicateCopied(hex, event.clientX, event.clientY))
        .catch(() => {
          showTooltip(event.clientX, event.clientY, 'Clipboard blocked');
          clearTimeout(tooltipCopyTimeout);
          tooltipCopyTimeout = setTimeout(() => {
            tooltipCopyTimeout = null;
            if (hoveredHex) {
              showTooltip(tooltipPosition.x, tooltipPosition.y, hoveredHex);
            } else {
              hideTooltip();
            }
          }, 900);
        });
    }

    function handleImageHover(event) {
      if (!loadedImage || !imageImageData || !samples.length) return;
      const coords = getCanvasPointer(event, imageCanvas);
      if (!coords) {
        clearHover(true, 'image');
        return;
      }
      const { x, y } = coords;
      if (!isWithinImageRegion(x, y)) {
        clearHover(true, 'image');
        return;
      }
      const color = getPixelColorAt(Math.floor(x), Math.floor(y));
      if (!color) {
        clearHover(true, 'image');
        return;
      }
      const lab = rgbToLab(color.r, color.g, color.b);
      const nearestSample = findNearestSampleByLab(lab);
      if (!nearestSample) {
        clearHover(true, 'image');
        return;
      }

      if (hoveredSample !== nearestSample || hoverSource !== 'image') {
        hoveredSample = nearestSample;
        hoveredHex = rgbToHex(nearestSample.rgb);
        hoverAmount = 0;
        hoverAmountTarget = 1;
        hoverSource = 'image';
        requestRender();
        applyImageHighlight(nearestSample);
      } else {
        hoverSource = 'image';
      }

      showTooltip(event.clientX, event.clientY, hoveredHex);
    }

    function handleImageLeave() {
      clearHover(true, 'image');
    }

    function clearHover(shouldRedraw = true, sourceFilter = null) {
      if (sourceFilter && hoverSource !== sourceFilter) {
        return;
      }
      if (hoveredSample) {
        hoveredSample = null;
        hoveredHex = '';
        hoverAmountTarget = 0;
        hoverSource = null;
        if (shouldRedraw) requestRender();
      } else {
        hoverSource = null;
      }
      if (highlightActive) {
        restoreBaseImage();
      }
      hideTooltip();
    }

    function getCanvasPointer(event, canvas) {
      const rect = canvas.getBoundingClientRect();
      if (!rect.width || !rect.height) return null;
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return {
        x: (event.clientX - rect.left) * scaleX,
        y: (event.clientY - rect.top) * scaleY
      };
    }

    function isWithinImageRegion(x, y) {
      return (
        x >= imageDrawRegion.x &&
        x <= imageDrawRegion.x + imageDrawRegion.width &&
        y >= imageDrawRegion.y &&
        y <= imageDrawRegion.y + imageDrawRegion.height
      );
    }

    function getPixelColorAt(x, y) {
      if (!imageImageData) return null;
      if (x < 0 || y < 0 || x >= imageCanvas.width || y >= imageCanvas.height) return null;
      const idx = (y * imageCanvas.width + x) * 4;
      const data = imageImageData.data;
      return {
        r: data[idx],
        g: data[idx + 1],
        b: data[idx + 2],
        a: data[idx + 3]
      };
    }

    function findNearestSampleByLab(targetLab) {
      if (!samples.length) return null;
      let nearest = null;
      let minDelta = Infinity;
      for (const sample of samples) {
        const delta = labDistance(sample.lab, targetLab);
        if (delta < minDelta) {
          minDelta = delta;
          nearest = sample;
        }
      }
      return nearest;
    }

    function labDistance(labA, labB) {
      const dL = labA.L - labB.L;
      const da = labA.a - labB.a;
      const db = labA.b - labB.b;
      return Math.sqrt(dL * dL + da * da + db * db);
    }

    function applyImageHighlight(sample) {
      if (!loadedImage || !imageImageData || !imageLabBuffer || !highlightImageData) return;
      if (highlightActive && lastHighlightSample === sample) {
        return;
      }
      const src = imageImageData.data;
      const dest = highlightImageData.data;
      const labBuffer = imageLabBuffer;
      const { L, a, b } = sample.lab;
      const threshold = highlightTolerance;
      for (let i = 0, j = 0; i < src.length; i += 4, j += 3) {
        const dL = labBuffer[j] - L;
        const da = labBuffer[j + 1] - a;
        const db = labBuffer[j + 2] - b;
        const delta = Math.sqrt(dL * dL + da * da + db * db);
        if (delta <= threshold) {
          dest[i] = src[i];
          dest[i + 1] = src[i + 1];
          dest[i + 2] = src[i + 2];
          dest[i + 3] = src[i + 3];
        } else {
          dest[i] = src[i] * DIM_FACTOR;
          dest[i + 1] = src[i + 1] * DIM_FACTOR;
          dest[i + 2] = src[i + 2] * DIM_FACTOR;
          dest[i + 3] = src[i + 3];
        }
      }
      imageCtx.putImageData(highlightImageData, 0, 0);
      highlightActive = true;
      lastHighlightSample = sample;
    }

    function restoreBaseImage() {
      if (!imageImageData) return;
      imageCtx.putImageData(imageImageData, 0, 0);
      highlightActive = false;
      lastHighlightSample = null;
    }

    function copyToClipboard(text) {
      if (navigator.clipboard?.writeText) {
        return navigator.clipboard.writeText(text);
      }
      return new Promise((resolve, reject) => {
        const input = document.createElement('input');
        input.value = text;
        document.body.appendChild(input);
        input.select();
        input.setSelectionRange(0, text.length);
        try {
          document.execCommand('copy');
          resolve();
        } catch (error) {
          reject(error);
        } finally {
          document.body.removeChild(input);
        }
      });
    }

    function indicateCopied(hex, x, y) {
      showTooltip(x, y, `${hex} copied`);
      clearTimeout(tooltipCopyTimeout);
      tooltipCopyTimeout = setTimeout(() => {
        tooltipCopyTimeout = null;
        if (hoveredHex) {
          showTooltip(tooltipPosition.x, tooltipPosition.y, hoveredHex);
        } else {
          hideTooltip();
        }
      }, 900);
    }

    function showTooltip(x, y, text) {
      tooltipPosition = { x, y };
      tooltip.textContent = text;
      const offset = 14;
      let left = x + offset;
      let top = y + offset;
      const padding = 8;
      const maxLeft = window.innerWidth - padding;
      const maxTop = window.innerHeight - padding;
      tooltip.style.left = `${Math.max(padding, Math.min(left, maxLeft))}px`;
      tooltip.style.top = `${Math.max(padding, Math.min(top, maxTop))}px`;
      tooltip.classList.add('visible');
    }

    function hideTooltip() {
      tooltip.classList.remove('visible');
      clearTimeout(tooltipCopyTimeout);
      tooltipCopyTimeout = null;
    }

    function animationLoop(timestamp = 0) {
      requestAnimationFrame(animationLoop);
      if (!lastFrameTime) lastFrameTime = timestamp;

      let dirty = needsRender;
      const rotX = approach(rotation.x, targetRotation.x, ROTATION_EASING);
      const rotY = approach(rotation.y, targetRotation.y, ROTATION_EASING);
      const zoomStep = approach(zoom, targetZoom, ZOOM_EASING);
      const hoverStep = approach(hoverAmount, hoverAmountTarget, HOVER_EASING);

      if (rotX.changed) {
        rotation.x = rotX.value;
        dirty = true;
      }
      if (rotY.changed) {
        rotation.y = rotY.value;
        dirty = true;
      }
      if (zoomStep.changed) {
        zoom = zoomStep.value;
        dirty = true;
      }
      if (hoverStep.changed) {
        hoverAmount = hoverStep.value;
        dirty = true;
      }

      if (dirty) {
        drawSpace();
        needsRender = false;
      }
    }

    function approach(current, target, easing) {
      if (Math.abs(target - current) < 0.0005) {
        return { value: target, changed: current !== target };
      }
      const value = current + (target - current) * easing;
      return { value, changed: true };
    }

    function requestRender() {
      needsRender = true;
    }

    function setColorUiVisible(isVisible) {
      if (cubeSection) cubeSection.classList.toggle('hidden', !isVisible);
      if (optionsSection) optionsSection.classList.toggle('hidden', !isVisible);
      resetButton.classList.toggle('hidden', !isVisible);
      if (isVisible) {
        requestAnimationFrame(() => {
          if (resizeCanvas(spaceCanvas)) {
            requestRender();
          }
          requestRender();
        });
      }
    }

    function handleImageClick(event) {
      if (!loadedImage) {
        fileInput?.click();
        return;
      }
      const coords = getCanvasPointer(event, imageCanvas);
      if (!coords || !isWithinImageRegion(coords.x, coords.y)) {
        return;
      }
      const color = getPixelColorAt(Math.floor(coords.x), Math.floor(coords.y));
      if (!color) return;
      const hex = rgbToHex([color.r, color.g, color.b]);
      hoveredHex = hex;
      copyToClipboard(hex)
        .then(() => indicateCopied(hex, event.clientX, event.clientY))
        .catch(() => indicateCopied(hex, event.clientX, event.clientY));
    }

    function handlePreviewKey(event) {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        if (!loadedImage) {
          fileInput?.click();
        } else if (hoveredSample) {
          const hex = hoveredHex || rgbToHex(hoveredSample.rgb);
          const rect = imageCanvas.getBoundingClientRect();
          const clientX = rect.left + rect.width / 2;
          const clientY = rect.top + rect.height / 2;
          copyToClipboard(hex)
            .then(() => indicateCopied(hex, clientX, clientY))
            .catch(() => indicateCopied(hex, clientX, clientY));
        } else {
          fileInput?.click();
        }
      }
    }

    function handleSampleChange() {
      const nextValue = parseInt(sampleSlider.value, 10);
      if (!Number.isFinite(nextValue)) return;
      sampleTarget = nextValue;
      syncSampleLabel();
      if (loadedImage) {
        samples = sampleImage(loadedImage);
        clearHover(false);
        requestRender();
      }
    }

    function syncSampleLabel() {
      if (sampleCountLabel) {
        sampleCountLabel.textContent = sampleTarget.toLocaleString();
      }
    }

    function handleToleranceChange() {
      const nextValue = parseInt(toleranceSlider.value, 10);
      if (!Number.isFinite(nextValue)) return;
      highlightTolerance = nextValue;
      syncToleranceLabel();
      if (hoveredSample) {
        applyImageHighlight(hoveredSample);
      }
    }

    function syncToleranceLabel() {
      if (toleranceLabel) {
        toleranceLabel.textContent = `${highlightTolerance} ΔE`;
      }
    }

    function rgbToLab(r, g, b) {
      const [x, y, z] = rgbToXyz(r, g, b);
      return xyzToLab(x, y, z);
    }

    function rgbToXyz(r, g, b) {
      const sr = pivotRgb(r / 255);
      const sg = pivotRgb(g / 255);
      const sb = pivotRgb(b / 255);
      const x = sr * 0.4124564 + sg * 0.3575761 + sb * 0.1804375;
      const y = sr * 0.2126729 + sg * 0.7151522 + sb * 0.0721750;
      const z = sr * 0.0193339 + sg * 0.1191920 + sb * 0.9503041;
      return [x, y, z];
    }

    function xyzToLab(x, y, z) {
      const refX = 0.95047;
      const refY = 1.0;
      const refZ = 1.08883;
      const fx = pivotXyz(x / refX);
      const fy = pivotXyz(y / refY);
      const fz = pivotXyz(z / refZ);
      const L = 116 * fy - 16;
      const a = 500 * (fx - fy);
      const b = 200 * (fy - fz);
      return { L, a, b };
    }

    function labToLch(L, a, b) {
      const C = Math.sqrt(a * a + b * b);
      let h = Math.atan2(b, a) * (180 / Math.PI);
      if (h < 0) h += 360;
      return { L, C, h };
    }

    function lchToLab(L, C, h) {
      const hr = (h * Math.PI) / 180;
      return {
        L,
        a: Math.cos(hr) * C,
        b: Math.sin(hr) * C
      };
    }

    function labToRgb(L, a, b) {
      const [x, y, z] = labToXyz(L, a, b);
      return xyzToRgb(x, y, z);
    }

    function labToXyz(L, a, b) {
      const refX = 0.95047;
      const refY = 1.0;
      const refZ = 1.08883;
      const epsilon = 0.008856;
      const kappa = 903.3;

      const fy = (L + 16) / 116;
      const fx = fy + a / 500;
      const fz = fy - b / 200;

      const fx3 = fx ** 3;
      const fy3 = fy ** 3;
      const fz3 = fz ** 3;

      const xr = fx3 > epsilon ? fx3 : (116 * fx - 16) / kappa;
      const yr = L > (kappa * epsilon) ? fy3 : L / kappa;
      const zr = fz3 > epsilon ? fz3 : (116 * fz - 16) / kappa;

      return [xr * refX, yr * refY, zr * refZ];
    }

    function xyzToRgb(x, y, z) {
      let r = x * 3.2404542 + y * -1.5371385 + z * -0.4985314;
      let g = x * -0.9692660 + y * 1.8760108 + z * 0.0415560;
      let b = x * 0.0556434 + y * -0.2040259 + z * 1.0572252;

      r = srgbFromLinear(r);
      g = srgbFromLinear(g);
      b = srgbFromLinear(b);

      if (![r, g, b].every(Number.isFinite)) return null;

      return [
        Math.round(clamp(r * 255, 0, 255)),
        Math.round(clamp(g * 255, 0, 255)),
        Math.round(clamp(b * 255, 0, 255))
      ];
    }

    function srgbFromLinear(value) {
      const v = clamp(value, 0, 1);
      return v <= 0.0031308 ? 12.92 * v : 1.055 * Math.pow(v, 1 / 2.4) - 0.055;
    }

    function pivotRgb(value) {
      return value <= 0.04045 ? value / 12.92 : Math.pow((value + 0.055) / 1.055, 2.4);
    }

    function pivotXyz(value) {
      const epsilon = 0.008856;
      const kappa = 903.3;
      return value > epsilon ? Math.cbrt(value) : (kappa * value + 16) / 116;
    }

    function coordsToColor(mode, coords) {
      if (mode === 'rgb') {
        return [
          Math.round(coords.x * 255),
          Math.round(coords.y * 255),
          Math.round(coords.z * 255)
        ];
      }
      if (mode === 'lab') {
        const lab = {
          L: coords.z * 100,
          a: coords.x * 255 - 128,
          b: coords.y * 255 - 128
        };
        return labToRgb(lab.L, lab.a, lab.b);
      }
      if (mode === 'lch') {
        const lab = lchToLab(coords.z * 100, coords.x * MAX_CHROMA, coords.y * 360);
        return labToRgb(lab.L, lab.a, lab.b);
      }
      return null;
    }

    function createReferenceGrid(steps) {
      const points = [];
      if (steps < 2) return [{ x: 0.5, y: 0.5, z: 0.5 }];
      const max = steps - 1;
      for (let ix = 0; ix < steps; ix++) {
        for (let iy = 0; iy < steps; iy++) {
          for (let iz = 0; iz < steps; iz++) {
            points.push({
              x: ix / max,
              y: iy / max,
              z: iz / max
            });
          }
        }
      }
      return points;
    }

    function rgbToHex(rgb) {
      const toHex = (value) => {
        const safe = Math.round(clamp(value, 0, 255));
        return safe.toString(16).padStart(2, '0');
      };
      return `#${toHex(rgb[0])}${toHex(rgb[1])}${toHex(rgb[2])}`.toUpperCase();
    }
  </script>
</body>
</html>

